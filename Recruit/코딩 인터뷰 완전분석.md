## 이력서
- 미국 기준 경력 10년 미만인 경우 이력서는 한 페이지가 적당하다.
    - 10년 이상이면 ~ 2페이지까지가 적당하다.
- 이력서는 짧으면 짧을수록 인상에 남는다.
- 구인 담당자는 이력서를 볼 때 짧은 시간만 사용한다.
- 이력서가 너무 길다면 무시할 수도 있다.
- 필요한 것만 쓰자.
- 성취는 "Y를 구현해서 X를 성취했고, 그 결과 Z를 이루었다." 형식으로 작성한다.
- 프로젝트는 가장 중요했던 프로젝트 2~4개를 적는다.
    - 무슨 프로젝트였는지, 어떤 언어와 기술을 사용했는지 적는다.
    - 자주성을 보여준다는 점에서 수업 프로젝트보다는 독립된 프로젝트를 더 선호한다.
- 프로그래밍 언어는 숙련도와 함께 적는다.
    - 프로그래밍 언어: 자바(전문가), c++(능숙), 자바스크립트(경험 있음)
- 오타를 내지 않는다.


## 행동 문제
- 프로젝트 3개정도는 아래의 요소에 대해 자세히 말할 수 있어야한다.(이를 표로 작성해서 시각화를 하자.)
    - 가장 도전적이었던 것
    - 실수 혹은 실패담
    - 즐거웠던 것
    - 리더쉽
    - 팀원과의 갈등
    - 남들과 다르게 행동했던 것
- 단점은 실제 단점을 말한다.
- 면접관에게 질문 거리를 준비한다.
- 프로젝트에 대한 질문에 대한 답은 구체적이되, 오만한 태도는 보이지 말자.
- 처음부터 너무 상세하게 말하지 말고 핵심 부분만 말한뒤 여지를 남기자.


## 시간복잡도 big-O

```java
void printUnorderedPairs(int[] arrayA, int[] arrayB) {
    for (int i = 0; i < arrayA.length; i++) {
        for (int j = 0; j < arrayB.length; ++j) {
            /* O(1) 시간이 걸리는 작업 */
        }
    }
}
```

위 코드의 시간 복잡도는 **O(ab)**이다. O(N^2)라고 말하면 안된다. 두 배열의 크기가 다르므로 이를 따로 고려해야한다.

```java
void printUnorderedPairs(int[] arrayA, int[] arrayB) {
    for (int i = 0; i < arrayA.length; i++) {
        for (int j = 0; j < arrayB.length; ++j) {
            for (int k = 0; k < 100000; k++) {
                System.out.println(arrayA[i] + "," + arrayB[i]);
            }
        }
    }
}
```

위 코드의 시간 복잡도도 여전히 **O(ab)**이다. 100,000은 여전히 상수항으로 간주된다.

#### 예제 8
여러 개의 문자열로 구성된 배열이 주어졌을 때 각각의 문자열을 먼저 정렬하고 그 다음에 전체 문자열을 사전순으로 다시 정렬하는 알고리즘이 있다고 가정하자. 이 알고리즘의 수행 시간은 어떻게 되겠는가?

대부분 위 문제의 시간복잡도를 O(N^2logN)이라고 한다. 이는 서로 다른 두 가지 경우에 N을 혼용해서 사용한 점이 문제이다.

위와 같은 문제를 풀 때는 서로 다른 요소를 연상 가능한 이름을 사용해서 새로운 변수로 정의해서 문제를 풀어야 한다.
- 가장 길이가 긴 문자열의 길이 s
- 배열의 길이 a

이제 각 부분의 시간 복잡도를 구해보자.
- 각 문자열을 정렬하는데 O(slogs)
- a개의 문자열 모두를 정렬해야 하므로, O(a*slogs)
- 전체 문자열을 사전순으로 정렬
    - 문자열 두 개를 비교하는데 O(s)
    - a개의 문자열을 정렬하는데 O(aloga)
    - 합계 O(a*sloga)
- 위 두 부분을 더해주면 전체 시간 복잡도는 **O(a*s(loga + logs))**이다.

#### 예제 9
균형 이진 탐색 트리에서 모든 노드의 값을 더하는 코드에서 시간 복잡도를 구하라.

```java
int sum(Node node) {
    if (node == null) {
        return 0;
    }
    return sum(node.left) + node.value + sum(node.right);
}
```

- 코드의 의미로 해결하기
    - 트리의 각 노드를 한 번씩 방문한 뒤 각 노드에서 재귀 호출 부분을 제외하고 상수 시간에 해당하는 일을 수행한다.
    - 수행 시간은 노드의 개수와 선형 관계이므로 O(N)
- 재귀호출 패턴분석
    - 일반적으로 재귀함수에서 분기가 여러 개 존재할 경우 **O(분기^깊이)**이다.
    - 위 코드는 분기가 2개 이므로 O(2^깊이)
    - 균형 이진 탐색 트리에서 깊이는 logN
    - 결과적으로 O(N)
    
#### 예제 10
다음은 현재의 값보다 작은 수들로 나누어 떨어지는지 확인함으로써 현재의 값이 소수인지 아닌지 판별하는 함수이다.
- 현재의 값보다 작은 수 전체를 나눠보면서 확인할 필요없이 현재의 값 제곱근까지만 확인하면 된다.

```java
boolean isPrime(int n) {
    for (int x = 2; x * x <= n; x++) {
        if (n % x == 0) {
            return false;
        }
    }
    return true;
}
```

여기서 시간복잡도는 for문이 최악인 경우 얼만큼 반복하는지 분석하면 된다. 위 코드의 for문은 x=2 ~ x*x=n까지 반복하며 이는 제곱근 n까지 반복한다는 의미이다.

```java
boolean isPrime(int n) {
    for (int x = 2; x <= sqrt(n)>; x++) {
        if (n % x == 0) {
            return false;
        }
    }
    return true;
}
```

따라서 시간 복잡도는 O(제곱근 n)이다.

#### 예제 12
문자열로 나타낼 수 있는 순열의 개수를 구하는 코드

```java
void permutation(String str) {
    permutation(str, "");
}

void permutation(String str, String prefix) {
    if (str.length() == 0) {
        System.out.println(prefix);
    } else {
        for (int i = 0; i < str.length(); i++) {
            String rem = str.substring(0, i) + str.substring(i + 1);
            permutation(rem, prefix + str.charAt(i));
        }
    }
}
```

- 순열이 완성되는 시점에 `permutation()` 함수는 몇 번 호출되는가
    - 만약 문자열 길이가 7이면, 첫 번째 자리는 7개의 선택권, 두 번째는 6개의 선택권,...
    - 총 `7*6*5*4*3*2*1`로 7!이다.
    - n! 번 호출
- 순열 생성이 완성되기 전에 `permutation()` 함수는 몇 번 호출되는가
    - 모든 호출을 나타내는 트리를 생각해봤을 때 말단 노드의 개수는 n!이고, 루트에서 각 말단 노드까지의 거리는 최대 n이다.
    - 최대 n*n! 번 호출
- 각 함수 호출을 처리하는데 얼마나 오래 걸리나
    - 문자열 전체를 출력하는 연산 O(N)
    - 문자열을 연결해주는 연산 O(N)
- 총 수행 시간
    - `permutation()` 함수는 총 O(n*n!) 호출되고, 호출될 때마다 O(N) 시간이 걸린다.
    - O(n^2*n!)

### 예제 13
N번째 피보나치 수(Fibonacci number) 구하기

```java
int fib(int n) {
    if (n <= 0) return 0;
    else if (n == 1) return 1;
    return fib(n - 1) + fib(n - 2);
}
```

- O(분기^깊이)
- O(2^N)

#### 예제 15
피보나치 수열을 0부터 n까지 모두 출력하는 코드(이전에 계산된 결과값을 캐시함)

```java
void allFib(int n) {
    int[] memo = new int[n + 1];
    for (int i = 0; i < n; i++) {
        System.out.println(i + ": " + fib(i, memo));
    }
}

int fib(int n, int[] memo) {
    if (n <= 0) return 0;
    else if (n == 1) return 1;
    else if (memo[n] > 0) return memo[n];
    memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
    return memo[n];
}
```

- 상수 시간의 일을 N번 반복하므로 총 O(N)
- 위는 지수 시간이 걸리는 재귀 알고리즘을 최적화하는데 자주 쓰이는 메모이제이션이다.

#### 예제 16
1과 n을 포함하여 그 삳이에 있는 모든 2의 승수(powers of 2)를 출력하는 함수

```java
int powersOf2(int n) {
    if (n < 1) {
        return 0;
    } else if (n == 1) {
        System.out.println(1);
    } else {
        int prev = powersOf2(n / 2);
        int curr = prev * 2;
        System.out.println(curr);
        return curr;
    }
}
```

- 함수가 어떻게 동작하는가

```
powersOf2(50)
    powersOf2(25)
        powersOf2(12)
            powersOf2(6)
                powersOf2(3)
                    powersOf2(1)
                    print & return 1
                print & return 2
            print & return 4
        print & return 8
    print & return 16
print & return 32
```

수행 시간은 n이 기본값인 1이 될 때까지 2로 나누는 횟수이다. 따라서 O(logn)이 된다.

#### 자연수의 제곱근을 구하는 코드

```java
int sqrt(int n) {
    return sqrt_helper(n, 1, n);
}

int sqrt_helper(int n, int min, int max) {
    if (max < min) return -1;  // 제곱근이 없다.
    
    int guess = (min + max) / 2;
    if (guess * guess == n) {  // 찾았다.
        return guess;
    } else if (guess * guess < n) {  // 너무 작다.
        return sqrt_helper(n, guess + 1, max);  // 더 큰 값으로 시도
    } else {  // 너무 크다.
        return sqrt_helper(n, min, guess - 1);  // 더 작은 값으로 시도
    }
}
```

- 시간 복잡도: O(logN)


## 기술적 문제
#### 문제를 접근하는 과정
1. 직접 풀도록 노력하다.
2. 코드를 종이에 적어라.
3. 코드를 테스트하라.
4. 종이에 적은 코드를 그대로 컴퓨터로 옮긴 뒤 실제로 실행해 보라.

#### 핵심 자료구조, 알고리즘, 기본 개념
- 자료구조
    - 연결리스트
    - 트리, 트라이, 그래프
    - 스택, 큐
    - 힙
    - Vector/ArrayList
    - 해시테이블
- 알고리즘
    - DFS, BFS
    - 이진 탐색
    - 병합 정렬
    - 퀵 정렬
- 개념
    - 비트 조작
    - 메모리(스택 VS 힙)
    - 재귀
    - 동적 프로그래밍
    - big-O 시간 & 공간

#### 2의 승수(power of 2) 표

| X | 2^X | 근사치 | 메모리 요구량 |
|----|-------------------|-----------------------|---------------|
| 7 | 128 |  |  |
| 8 | 256 |  |  |
| 10 | 1024 | 1000(천) | 1K |
| 16 | 65,536 |  | 64K |
| 20 | 1,048,576 | 1,000,000(백만) | 1MB |
| 30 | 1,073,741,824 | 1,000,000,000(십억) | 1GB |
| 32 | 4,294,967,296 |  | 4GB |
| 40 | 1,099,511,627,776 | 1,000,000,000,000(조) | 1TB |

#### 풀이 과정
1. 듣기
- 문제 설명과 관련된 것이라면 어떤 정보든지 아주 집중해야한다.
- 최적 알고리즘을 설계하기 위해선 모든 정보가 필요할지도 모른다.

2. 예제
- 대부분의 예제들은 크기가 아주 작거나 특별한 사례인 경우가 많다.
- 직접 예제를 만들어서 디버깅하라.
- 직접 만든 예제가 특별한 경우인가? 충분히 큰 입력인가?

3. 무식하게 풀기
- 우선은 빨리 무식한 방법(brute force)으로 푼다.
- 알고리즘의 효율을 높이려고 미리 애쓰지 말라.
- 아주 단순한 알고리즘 및 시간 복잡도를 먼저 말한 다음에 최적화하라.
- 아직 코딩할 단계가 아니다!

4. 최적화
- BUD 최적화를 통해 무식하게 푼 방법을 개선하라.
    - BUD 최적화
        - 병목현상(Bottlenecks)
        - 불필요한 작업(Unnecessary Work)
        - 중복되는 작업(Duplicated Work)
- 간과한 부분이 있는지 생각해 보자.
- 예제를 손으로 풀어 본 뒤 사고 과정을 되짚어 보라.
- 잘못된 방법으로 문제를 풀어 본 뒤 왜 알고리즘이 틀렸는지 생각해 보라. 여기서 발견된 문제를 해결할 수 있는가?
- 시간과 공간의 비용-이익 관계를 고려하라. 이 때 해시테이블이 특히 유용하다.

5. 검토하기
- 최적의 해법을 찾았다면, 다시 한번 자세하게 검토하자.

6. 구현하기
- 코드를 깔끔하게 구현한다.

7. 테스트
- 다음의 순서로 테스트해보자.
    - 개념적 테스트: 마치 코드 리뷰를 하듯이 자세하게 코드를 훑어보며 테스트하기
    - 특이하거나 표준적이지 않은 코드
    - 산술연산 혹은 널(null) 노드와 같이 실수가 날 만한 부분
    - 작은 크기의 테스트들
    - 특이하거나 극단적인 입력


## 자료구조
### 배열과 문자열
- 해시테이블
    - 효율적인 탐색을 위한 자료구조
    - 키(key)를 값(value)에 대응시킨다.
    - 해시테이블을 간단하게 구현하기 위해서는 연결리스트와 해시 코드함수만 있으면 된다. => 평균 탐색 시간 O(1)
    - 균형 이진 탐색 트리로도 구현할 수 있다. => 탐색 시간 O(logN)
- ArrayList와 가변 크기 배열
    - 동적 가변 크기 기능이 내재되어 있는 배열은 배열이 가득 차는 순간, 배열의 크기를 두 배로 늘린다.
    - 두 배로 늘리는 시간은 O(n)이지만, 자주 발생하지 않아 상환 입력 시간으로 계산했을 때 O(1)이다.
    - StringBuilder는 가변 크기 배열을 이용하여 효율적으로 구현되어 있다.

### 면접 문제
#### 1.1 중복이 없는가?

```cpp
bool isDuplicatedCharacter(string input) {
    vector<int> duplicated(26);

    for (int i=0; i<input.size(); ++i) {
        duplicated[input[i] - 'a']++;
    }

    for (int i=0; i<26; ++i) {
        if (duplicated[i] > 1) {
            return true;
        }
    }

    return false;
}
```

- 자료구조 없이 구현해보기

```cpp
bool isDuplicatedCharacter(string input) {
    for (int i=0; i<input.size()-1; ++i) {
        for (int j=i+1; j<input.size(); ++i) {
            if (input[i] == input[j]) {
                return true;
            }
        }
    }

    return false;
}
```

- 문자열이 ASCII 문자열인지 유니코드 문자열인지 확인

```java
boolean isUniqueChares(String str) {
    if (str.length() > 128) return false;
    boolean[] char_set = new boolean[128];
    for (int i=0; i<str.length(); ++i) {
        int val = str.charAt(i);
        if (char_set[val]) {
            return false;
        }
        char_set[val] = true;
    }

    return true;
}
```

- 시간 복잡도: O(n) (최대 길이가 128 이하이므로 O(1) 주장 가능)
- 공간 복잡도: O(1)

```java
boolean isUniqueChars(String str) {
    int checker = 0;
    for (int i=0; i<size.length(); ++i) {
        int val = str.charAt(i) - 'a';
        if ((checker & (1 << val)) > 0) {
            return false;
        }
        checker |= (1 << val);
    }
    return true;
}
```

- 비트 백터를 사용하면 필요한 공간을 1/8로 줄일 수 있다.

#### 1.2 순열 확인

```cpp
bool solve(string s1, string s2) {
    if (s1.size() != s2.size()) return false;

    vector<int> alphabetFreq1(26), alphabetFreq2(26);

    for (int i=0; i<s1.size(); ++i) {
        alphabetFreq1[s1[i] - 'a']++;
        alphabetFreq2[s2[i] - 'a']++;
    }

    for (int i=0; i<26; ++i) {
        if (alphabetFreq1[i] != alphabetFreq2[i]) {
            return false;
        }
    }

    return true;
}
```

두 문자열이 순열 관계라는 것은 같은 문자로 구성되어 있고 순서만 다르다는 것이다. 그렇다면 두 문자열을 정렬하면 같은 결과가 나와야 한다.

```java
public String sort(String s) {
    char[] content = s.toCharArray();
    java.util.Arrays.sort(content);
    return new String(content);
}

public boolean permutation(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }
    return sort(s).equals(sort(t));
}
```

- 위 알고리즘이 최적은 아니지만 단순해서 이해하기 좋음


#### 1.3 URI화

```java
public String solve(String input) {
    input.replaceAll(" ", "%20");

    return input;
}
```

문자열 조작 문제를 풀 때 널리 사용하는 방법 중 하나는 문자열을 뒤에서부터 거꾸로 편집해나간다. 왜냐하면 마지막 부분에 여유 공간ㅇ르 만들어 유용하게 사용할 수 있다. 이 방법을 쓰면 덮어쓸 걱정도 하지 않아도 된다.

```java
void replaceSpaces(char[] str, int trueLength) {
    int spaceCount = 0, index, i = 0;
    for (i=0; i<trueLength; ++i) {
        if (str[i] == ' ') {
            spaceCount++;
        }
    }
    index = truLength + spaceCount * 2;
    if (trueLength < str.length) str[trueLength] '/0';
    for (i=trueLength - 1; i>=0; --i) {
        if (str[i] == ' ') {
            str[index - 1] = '0';
            str[index - 2] = '2';
            str[index - 3] = '%';
            index = index - 3;
        } else {
            str[index - 1] = str[i];
            index--;
        }
    }
}
```

#### 1.4 회문 순열

```cpp
bool ans = false;
void permutation(string str, int size) {
    if (str.size() == size) {
        int s = 0;
        int e = size() - 1;
        for (int i=0; i<size()/2; ++i) {
            if (str[s] != str[e]) return;
            s++;
            e--;
        }
    }

    // 순열
}
bool solve(string input) {
    input.replaceAll("", "");


}
```

문자열 길이가 짝수이면, 해당 문자열에 존재하는 모든 문자의 개수가 각각 짝수개여야 한다. 반대로 홀수이면 하나의 문자의 개수는 홀수일 수 있지만, 나머지는 반드시 개수가 짝수여야 한다.

```java
boolean isPermutationOfPalindrome(String phrase) {
    int[] table = buildCharFrequencyTable(phrase);
    return checkMaxOneOdd(table);
}

/* 홀수 문자가 한 개 이상 존재하는지 확인한다. */
boolean checkMaxOneOdd(int[] table) {
    boolean foundOdd = false;
    for (int count : table) {
        if (count % 2 == 1) {
            if (foundOdd) {
                return false;
            }
            foundOdd = true;
        }
    }
    return true;
}

/* 각 문자에 숫자를 대응시킨다. a->0, b->1, c->2 등등 
 * 대소문자 구분이 없고, 문자가 아닌 경우에는 -1로 대응시킨다. */
 int getCharNumber(Character c) {
     int a = Character.getNumericValue('a');
     int z = Character.getNumericValue('z');
     int val = Character.getNumericValue(c);
     if (a <= val && val <= z) {
         return val - a;
     }

     return -1;
 }

 /* 각 문자가 몇 번 등장했는지 센다. */
 int[] buildCharFrequencyTable(String phrase) {
     int[] table = new int[Character.getNumericValue('z') - Character.getNumericValue('a') + 1];
     for (char c : phrase.toCharArray()) {
         int x = getCharNumber(c);
         if (x != -1) {
             Table[x]++;
         }
     }
     return table;
 }
 ```

#### 1.5 하나 빼기
완전 탐색은 매우 느리다. 생각만해보고 구현은 하지말자.

#### 1.6 문자열 압축

```cpp
string solve(string input) {
    string compressed;

    for (int i=0; i<input.size()-1; ++i) {
        int len = 1;
        for (int j=i+1; j<input.size(); ++i) {
            if (input[i] == input[j]) {
                len++;
            } else {
                i = j-1;
                compressed.push_back(input[i]);
                compressed.push_back(len);
                break;
            }
        }
    }

    if (compressed.size() > input.size()) return input;
    else return compressed;
}
```

#### 1.7 행렬 회전

```cpp

```