## 이력서
- 미국 기준 경력 10년 미만인 경우 이력서는 한 페이지가 적당하다.
    - 10년 이상이면 ~ 2페이지까지가 적당하다.
- 이력서는 짧으면 짧을수록 인상에 남는다.
- 구인 담당자는 이력서를 볼 때 짧은 시간만 사용한다.
- 이력서가 너무 길다면 무시할 수도 있다.
- 필요한 것만 쓰자.
- 성취는 "Y를 구현해서 X를 성취했고, 그 결과 Z를 이루었다." 형식으로 작성한다.
- 프로젝트는 가장 중요했던 프로젝트 2~4개를 적는다.
    - 무슨 프로젝트였는지, 어떤 언어와 기술을 사용했는지 적는다.
    - 자주성을 보여준다는 점에서 수업 프로젝트보다는 독립된 프로젝트를 더 선호한다.
- 프로그래밍 언어는 숙련도와 함께 적는다.
    - 프로그래밍 언어: 자바(전문가), c++(능숙), 자바스크립트(경험 있음)
- 오타를 내지 않는다.


## 행동 문제
- 프로젝트 3개정도는 아래의 요소에 대해 자세히 말할 수 있어야한다.(이를 표로 작성해서 시각화를 하자.)
    - 가장 도전적이었던 것
    - 실수 혹은 실패담
    - 즐거웠던 것
    - 리더쉽
    - 팀원과의 갈등
    - 남들과 다르게 행동했던 것
- 단점은 실제 단점을 말한다.
- 면접관에게 질문 거리를 준비한다.
- 프로젝트에 대한 질문에 대한 답은 구체적이되, 오만한 태도는 보이지 말자.
- 처음부터 너무 상세하게 말하지 말고 핵심 부분만 말한뒤 여지를 남기자.


## 시간복잡도 big-O

```java
void printUnorderedPairs(int[] arrayA, int[] arrayB) {
    for (int i = 0; i < arrayA.length; i++) {
        for (int j = 0; j < arrayB.length; ++j) {
            /* O(1) 시간이 걸리는 작업 */
        }
    }
}
```

위 코드의 시간 복잡도는 **O(ab)**이다. O(N^2)라고 말하면 안된다. 두 배열의 크기가 다르므로 이를 따로 고려해야한다.

```java
void printUnorderedPairs(int[] arrayA, int[] arrayB) {
    for (int i = 0; i < arrayA.length; i++) {
        for (int j = 0; j < arrayB.length; ++j) {
            for (int k = 0; k < 100000; k++) {
                System.out.println(arrayA[i] + "," + arrayB[i]);
            }
        }
    }
}
```

위 코드의 시간 복잡도도 여전히 **O(ab)**이다. 100,000은 여전히 상수항으로 간주된다.

#### 예제 8
여러 개의 문자열로 구성된 배열이 주어졌을 때 각각의 문자열을 먼저 정렬하고 그 다음에 전체 문자열을 사전순으로 다시 정렬하는 알고리즘이 있다고 가정하자. 이 알고리즘의 수행 시간은 어떻게 되겠는가?

대부분 위 문제의 시간복잡도를 O(N^2logN)이라고 한다. 이는 서로 다른 두 가지 경우에 N을 혼용해서 사용한 점이 문제이다.

위와 같은 문제를 풀 때는 서로 다른 요소를 연상 가능한 이름을 사용해서 새로운 변수로 정의해서 문제를 풀어야 한다.
- 가장 길이가 긴 문자열의 길이 s
- 배열의 길이 a

이제 각 부분의 시간 복잡도를 구해보자.
- 각 문자열을 정렬하는데 O(slogs)
- a개의 문자열 모두를 정렬해야 하므로, O(a*slogs)
- 전체 문자열을 사전순으로 정렬
    - 문자열 두 개를 비교하는데 O(s)
    - a개의 문자열을 정렬하는데 O(aloga)
    - 합계 O(a*sloga)
- 위 두 부분을 더해주면 전체 시간 복잡도는 **O(a*s(loga + logs))**이다.

#### 예제 9
균형 이진 탐색 트리에서 모든 노드의 값을 더하는 코드에서 시간 복잡도를 구하라.

```java
int sum(Node node) {
    if (node == null) {
        return 0;
    }
    return sum(node.left) + node.value + sum(node.right);
}
```

- 코드의 의미로 해결하기
    - 트리의 각 노드를 한 번씩 방문한 뒤 각 노드에서 재귀 호출 부분을 제외하고 상수 시간에 해당하는 일을 수행한다.
    - 수행 시간은 노드의 개수와 선형 관계이므로 O(N)
- 재귀호출 패턴분석
    - 일반적으로 재귀함수에서 분기가 여러 개 존재할 경우 **O(분기^깊이)**이다.
    - 위 코드는 분기가 2개 이므로 O(2^깊이)
    - 균형 이진 탐색 트리에서 깊이는 logN
    - 결과적으로 O(N)
    
#### 예제 10
다음은 현재의 값보다 작은 수들로 나누어 떨어지는지 확인함으로써 현재의 값이 소수인지 아닌지 판별하는 함수이다.
- 현재의 값보다 작은 수 전체를 나눠보면서 확인할 필요없이 현재의 값 제곱근까지만 확인하면 된다.

```java
boolean isPrime(int n) {
    for (int x = 2; x * x <= n; x++) {
        if (n % x == 0) {
            return false;
        }
    }
    return true;
}
```

여기서 시간복잡도는 for문이 최악인 경우 얼만큼 반복하는지 분석하면 된다. 위 코드의 for문은 x=2 ~ x*x=n까지 반복하며 이는 제곱근 n까지 반복한다는 의미이다.

```java
boolean isPrime(int n) {
    for (int x = 2; x <= sqrt(n)>; x++) {
        if (n % x == 0) {
            return false;
        }
    }
    return true;
}
```

따라서 시간 복잡도는 O(제곱근 n)이다.

#### 예제 12
문자열로 나타낼 수 있는 순열의 개수를 구하는 코드

```java
void permutation(String str) {
    permutation(str, "");
}

void permutation(String str, String prefix) {
    if (str.length() == 0) {
        System.out.println(prefix);
    } else {
        for (int i = 0; i < str.length(); i++) {
            String rem = str.substring(0, i) + str.substring(i + 1);
            permutation(rem, prefix + str.charAt(i));
        }
    }
}
```

- 순열이 완성되는 시점에 `permutation()` 함수는 몇 번 호출되는가
    - 만약 문자열 길이가 7이면, 첫 번째 자리는 7개의 선택권, 두 번째는 6개의 선택권,...
    - 총 `7*6*5*4*3*2*1`로 7!이다.
    - n! 번 호출
- 순열 생성이 완성되기 전에 `permutation()` 함수는 몇 번 호출되는가
    - 모든 호출을 나타내는 트리를 생각해봤을 때 말단 노드의 개수는 n!이고, 루트에서 각 말단 노드까지의 거리는 최대 n이다.
    - 최대 n*n! 번 호출
- 각 함수 호출을 처리하는데 얼마나 오래 걸리나
    - 문자열 전체를 출력하는 연산 O(N)
    - 문자열을 연결해주는 연산 O(N)
- 총 수행 시간
    - `permutation()` 함수는 총 O(n*n!) 호출되고, 호출될 때마다 O(N) 시간이 걸린다.
    - O(n^2*n!)

### 예제 13
N번째 피보나치 수(Fibonacci number) 구하기

```java
int fib(int n) {
    if (n <= 0) return 0;
    else if (n == 1) return 1;
    return fib(n - 1) + fib(n - 2);
}
```

- O(분기^깊이)
- O(2^N)

#### 예제 15
피보나치 수열을 0부터 n까지 모두 출력하는 코드(이전에 계산된 결과값을 캐시함)

```java
void allFib(int n) {
    int[] memo = new int[n + 1];
    for (int i = 0; i < n; i++) {
        System.out.println(i + ": " + fib(i, memo));
    }
}

int fib(int n, int[] memo) {
    if (n <= 0) return 0;
    else if (n == 1) return 1;
    else if (memo[n] > 0) return memo[n];
    memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
    return memo[n];
}
```

- 상수 시간의 일을 N번 반복하므로 총 O(N)
- 위는 지수 시간이 걸리는 재귀 알고리즘을 최적화하는데 자주 쓰이는 메모이제이션이다.

#### 예제 16
1과 n을 포함하여 그 삳이에 있는 모든 2의 승수(powers of 2)를 출력하는 함수

```java
int powersOf2(int n) {
    if (n < 1) {
        return 0;
    } else if (n == 1) {
        System.out.println(1);
    } else {
        int prev = powersOf2(n / 2);
        int curr = prev * 2;
        System.out.println(curr);
        return curr;
    }
}
```

- 함수가 어떻게 동작하는가

```
powersOf2(50)
    powersOf2(25)
        powersOf2(12)
            powersOf2(6)
                powersOf2(3)
                    powersOf2(1)
                    print & return 1
                print & return 2
            print & return 4
        print & return 8
    print & return 16
print & return 32
```

수행 시간은 n이 기본값인 1이 될 때까지 2로 나누는 횟수이다. 따라서 O(logn)이 된다.

#### 자연수의 제곱근을 구하는 코드

```java
int sqrt(int n) {
    return sqrt_helper(n, 1, n);
}

int sqrt_helper(int n, int min, int max) {
    if (max < min) return -1;  // 제곱근이 없다.
    
    int guess = (min + max) / 2;
    if (guess * guess == n) {  // 찾았다.
        return guess;
    } else if (guess * guess < n) {  // 너무 작다.
        return sqrt_helper(n, guess + 1, max);  // 더 큰 값으로 시도
    } else {  // 너무 크다.
        return sqrt_helper(n, min, guess - 1);  // 더 작은 값으로 시도
    }
}
```

- 시간 복잡도: O(logN)


## 기술적 문제
#### 문제를 접근하는 과정
1. 직접 풀도록 노력하다.
2. 코드를 종이에 적어라.
3. 코드를 테스트하라.
4. 종이에 적은 코드를 그대로 컴퓨터로 옮긴 뒤 실제로 실행해 보라.

#### 핵심 자료구조, 알고리즘, 기본 개념
- 자료구조
    - 연결리스트
    - 트리, 트라이, 그래프
    - 스택, 큐
    - 힙
    - Vector/ArrayList
    - 해시테이블
- 알고리즘
    - DFS, BFS
    - 이진 탐색
    - 병합 정렬
    - 퀵 정렬
- 개념
    - 비트 조작
    - 메모리(스택 VS 힙)
    - 재귀
    - 동적 프로그래밍
    - big-O 시간 & 공간

#### 2의 승수(power of 2) 표

| X | 2^X | 근사치 | 메모리 요구량 |
|----|-------------------|-----------------------|---------------|
| 7 | 128 |  |  |
| 8 | 256 |  |  |
| 10 | 1024 | 1000(천) | 1K |
| 16 | 65,536 |  | 64K |
| 20 | 1,048,576 | 1,000,000(백만) | 1MB |
| 30 | 1,073,741,824 | 1,000,000,000(십억) | 1GB |
| 32 | 4,294,967,296 |  | 4GB |
| 40 | 1,099,511,627,776 | 1,000,000,000,000(조) | 1TB |

#### 풀이 과정
1. 듣기
- 문제 설명과 관련된 것이라면 어떤 정보든지 아주 집중해야한다.
- 최적 알고리즘을 설계하기 위해선 모든 정보가 필요할지도 모른다.

2. 예제
- 대부분의 예제들은 크기가 아주 작거나 특별한 사례인 경우가 많다.
- 직접 예제를 만들어서 디버깅하라.
- 직접 만든 예제가 특별한 경우인가? 충분히 큰 입력인가?

3. 무식하게 풀기
- 우선은 빨리 무식한 방법(brute force)으로 푼다.
- 알고리즘의 효율을 높이려고 미리 애쓰지 말라.
- 아주 단순한 알고리즘 및 시간 복잡도를 먼저 말한 다음에 최적화하라.
- 아직 코딩할 단계가 아니다!

4. 최적화
- BUD 최적화를 통해 무식하게 푼 방법을 개선하라.
    - BUD 최적화
        - 병목현상(Bottlenecks)
        - 불필요한 작업(Unnecessary Work)
        - 중복되는 작업(Duplicated Work)
- 간과한 부분이 있는지 생각해 보자.
- 예제를 손으로 풀어 본 뒤 사고 과정을 되짚어 보라.
- 잘못된 방법으로 문제를 풀어 본 뒤 왜 알고리즘이 틀렸는지 생각해 보라. 여기서 발견된 문제를 해결할 수 있는가?
- 시간과 공간의 비용-이익 관계를 고려하라. 이 때 해시테이블이 특히 유용하다.

5. 검토하기
- 최적의 해법을 찾았다면, 다시 한번 자세하게 검토하자.

6. 구현하기
- 코드를 깔끔하게 구현한다.

7. 테스트
- 다음의 순서로 테스트해보자.
    - 개념적 테스트: 마치 코드 리뷰를 하듯이 자세하게 코드를 훑어보며 테스트하기
    - 특이하거나 표준적이지 않은 코드
    - 산술연산 혹은 널(null) 노드와 같이 실수가 날 만한 부분
    - 작은 크기의 테스트들
    - 특이하거나 극단적인 입력


## 자료구조
### 배열과 문자열
- 해시테이블
    - 효율적인 탐색을 위한 자료구조
    - 키(key)를 값(value)에 대응시킨다.
    - 해시테이블을 간단하게 구현하기 위해서는 연결리스트와 해시 코드함수만 있으면 된다. => 평균 탐색 시간 O(1)
    - 균형 이진 탐색 트리로도 구현할 수 있다. => 탐색 시간 O(logN)
- ArrayList와 가변 크기 배열
    - 동적 가변 크기 기능이 내재되어 있는 배열은 배열이 가득 차는 순간, 배열의 크기를 두 배로 늘린다.
    - 두 배로 늘리는 시간은 O(n)이지만, 자주 발생하지 않아 상환 입력 시간으로 계산했을 때 O(1)이다.
    - StringBuilder는 가변 크기 배열을 이용하여 효율적으로 구현되어 있다.


## 객체 지향 설계
### 접근법
#### 1. 모호성의 해소
- 객체 지향 설계 관련 문제들은 대개 고의적으로 모호성을 띄고 있다.
    - 스스로 가정을 만들고, 면접관에게 질문을 통해 명확히 해나가는 과정을 보기 위함이다.
- 개발할 때 요구사항을 정확히 이해하지 못한 상황에서 바로 코딩하는 것은 시간 및 돈 낭비이다.
- 객체 지향 설계에 관한 질문을 받으면 누가 그것을 사용할지, 어떻게 사용할지 등을 질문해야한다.

#### 2. 핵심 객체의 설계
- 시스템에 넣을 핵심 객체(core object)가 무엇인지 생각해야한다.

#### 3. 관계 분석
- 객체 사이의 관계를 분석해야 한다.
    - 어떤 객체가 어떤 객체에 속해 있는가?
    - 다른 객체로부터 상속 받아야 하는 객체는 있나?
    - 관계는 다-대-다 or 일-대-다 인가?

#### 4. 행동 분석
- 이 단계까지 왔다면 객체 지향 설계의 골격은 어느 정도 잡힌 상태이다.
- 이 단계는 객체가 수행해야 하는 핵심 행동에 대해 생각하고, 이들이 어떻게 상호작용하는지 따져봐야한다.
    - 이 과정을 수행하다보면 깜빡 잊은 객체가 있을 수도 있고, 상황에 따라 설계를 변경해야 할 수도 있다.

### 디자인 패턴
- 대게 디자인 패턴은 면접 범위를 넘어서는 경우이다. 하지만 매우 자주 사용하는 싱글톤 패턴이나 팩토리 매서드 패턴 정도는 알고 있으면 좋다.


## 시스템 설계 및 규모 확장성
- 규모 확장성 문제는 가장 쉬운 종류의 문제이다.
    - 번뜩이는 아이디어를 요구하지도 않고, 트릭도 없고, 예쁜 알고리즘도 없다.(일반적인 경우)
- 이런 문제를 풀 때는 실제 일을 하듯이 하면 된다. 질문을 하라. 면접관을 끌어들이라. 장단점을 토란하라.

### 문제를 다루는 방법
- 소통하라: 시스템 설계 문제를 출제하는 가장 큰 목적은 의사소통 능력을 평가하기 위함이다.
- 처음에는 포괄적으로 접근하라.
- 화이트보드를 사용하라.
- 면접관이 우려하는 부분을 인정하라.: 면접관이 지적한 부분을 인정하고 적절히 수정하라.
- 가정을 할 때 주의하라
- 여러분이 생각하는 가정을 명확히 언급하라.
- 필요하다면 어림잡아 보라.
- 뛰어들라.


## 정렬과 탐색
### 병합 정렬

```java
void mergesort(int[] array) {
    int[] helper = new int[array.length];
    mergesort(array, helper, 0, array.length - 1);
}

void mergesort(int[] array, int[] helper, int low, int high) {
    if (low < high) {
        int mid = (low + high) / 2;
        mergesort(array, helper, low, mid);  // 왼쪽 절반 정렬
        mergesort(array, helper, mid + 1, high);  // 오른쪽 절반 정렬
        merge(array, helper, low, mid, high);  // 병합
    }
}

void merge(int[] array, int[] helper, int low, int mid, int high) {
    /* 절반짜리 두 배열을 helper 배열에 복사한다. */
    for (int i = low; i <= high; ++i) {
        helper[i] = array[i];
    }

    int helperLeft = low;
    int helperRight = mid + 1;
    int current = low;

    /* helper 배열 순회. 왼쪽 절반과 오른쪽 절반을 비교하여 작은 원소를
     * 절반짜리 두 배열을 helper 배열에 복사한다. */
     while (helperLeft <= mid && helperRight <= high) {
         if (helper[helperLeft] <= helper[helperRight]) {
             array[current] = helper[helperLeft];
             helperLeft++;
         } else {  // 오른쪽 원소가 왼쪽 원소보다 작으면
            array[current] = helper[helperRight];
            helperRight++;
         }
         current++;
     }

     /* 왼쪽 절반 배열에 남은 원소들을 원래 배열에 복사해 넣는다. */
     int remaining = mid - helperLeft;
     for (int i = 0; i <= remaining; ++i) {
         array[current + i] = helper[helperLeft + i];
     }
}
```

### 퀵 정렬

```java
void quickSort(int[] arr, int left, int right) {
    int mid = partition(arr, left, right);
    if (left < mid - 1) {  // 왼쪽 절반 정렬
        quickSort(arr, left, mid - 1);
    }
    if (mid < right) {     // 오른쪽 절반 정렬
        quickSort(arr, mid, right);
    }
}

int partition(int[] arr, int left, int right) {
    int pivot = arr[(left + right) / 2];  // 분할 기준 원소 선정
    while (left <= right) {
        // 왼쪽에서 오른쪽으로 옮겨야 하는 원소 탐색
        while (arr[left] < pivot) left++;

        // 오른쪽에서 왼쪽으로 옮겨야 하는 원소 탐색
        while (arr[right] > pivot) right--;

        // 원소를 스왑한 뒤 left와 right를 이동
        if (left <= right) {
            swap(arr, left, right);  // 스왑
            left++;
            right--;
        }
    }

    return left;
}
```

### 이진 탐색

```java
int binarySearch(int[] a, int x) {
    int low = 0;
    int high = a.length - 1;
    int mid;

    while(low <= high) {
        mid = (low + high) / 2;
        if (a[mid] < x) {
            low = mid + 1;
        } else if (a[mid] > x) {
            high = mid - 1;
        } else {
            return mid;
        }
    }
    
    return -1;
}

int binarySearchRecursive(int[] a, int x, int low, int high) {
    if (low > high) return -1;

    int mid = (low + high) / 2;
    if (a[mid] < x) {
        return binarySearchRecursive(a, x, mid + 1, high);
    } else if (a[mid] > x) {
        return binarySearchRecursive(a, x, low, mid - 1);
    } else {
        return mid;
    }
}
```


## 면접 문제
### 배열과 문자열
#### 1.1 중복이 없는가?

```cpp
bool isDuplicatedCharacter(string input) {
    vector<int> duplicated(26);

    for (int i=0; i<input.size(); ++i) {
        duplicated[input[i] - 'a']++;
    }

    for (int i=0; i<26; ++i) {
        if (duplicated[i] > 1) {
            return true;
        }
    }

    return false;
}
```

- 자료구조 없이 구현해보기

```cpp
bool isDuplicatedCharacter(string input) {
    for (int i=0; i<input.size()-1; ++i) {
        for (int j=i+1; j<input.size(); ++i) {
            if (input[i] == input[j]) {
                return true;
            }
        }
    }

    return false;
}
```

- 문자열이 ASCII 문자열인지 유니코드 문자열인지 확인

```java
boolean isUniqueChares(String str) {
    if (str.length() > 128) return false;
    boolean[] char_set = new boolean[128];
    for (int i=0; i<str.length(); ++i) {
        int val = str.charAt(i);
        if (char_set[val]) {
            return false;
        }
        char_set[val] = true;
    }

    return true;
}
```

- 시간 복잡도: O(n) (최대 길이가 128 이하이므로 O(1) 주장 가능)
- 공간 복잡도: O(1)

```java
boolean isUniqueChars(String str) {
    int checker = 0;
    for (int i=0; i<size.length(); ++i) {
        int val = str.charAt(i) - 'a';
        if ((checker & (1 << val)) > 0) {
            return false;
        }
        checker |= (1 << val);
    }
    return true;
}
```

- 비트 백터를 사용하면 필요한 공간을 1/8로 줄일 수 있다.

#### 1.2 순열 확인

```cpp
bool solve(string s1, string s2) {
    if (s1.size() != s2.size()) return false;

    vector<int> alphabetFreq1(26), alphabetFreq2(26);

    for (int i=0; i<s1.size(); ++i) {
        alphabetFreq1[s1[i] - 'a']++;
        alphabetFreq2[s2[i] - 'a']++;
    }

    for (int i=0; i<26; ++i) {
        if (alphabetFreq1[i] != alphabetFreq2[i]) {
            return false;
        }
    }

    return true;
}
```

두 문자열이 순열 관계라는 것은 같은 문자로 구성되어 있고 순서만 다르다는 것이다. 그렇다면 두 문자열을 정렬하면 같은 결과가 나와야 한다.

```java
public String sort(String s) {
    char[] content = s.toCharArray();
    java.util.Arrays.sort(content);
    return new String(content);
}

public boolean permutation(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }
    return sort(s).equals(sort(t));
}
```

- 위 알고리즘이 최적은 아니지만 단순해서 이해하기 좋음


#### 1.3 URI화

```java
public String solve(String input) {
    input.replaceAll(" ", "%20");

    return input;
}
```

문자열 조작 문제를 풀 때 널리 사용하는 방법 중 하나는 문자열을 뒤에서부터 거꾸로 편집해나간다. 왜냐하면 마지막 부분에 여유 공간ㅇ르 만들어 유용하게 사용할 수 있다. 이 방법을 쓰면 덮어쓸 걱정도 하지 않아도 된다.

```java
void replaceSpaces(char[] str, int trueLength) {
    int spaceCount = 0, index, i = 0;
    for (i=0; i<trueLength; ++i) {
        if (str[i] == ' ') {
            spaceCount++;
        }
    }
    index = truLength + spaceCount * 2;
    if (trueLength < str.length) str[trueLength] '/0';
    for (i=trueLength - 1; i>=0; --i) {
        if (str[i] == ' ') {
            str[index - 1] = '0';
            str[index - 2] = '2';
            str[index - 3] = '%';
            index = index - 3;
        } else {
            str[index - 1] = str[i];
            index--;
        }
    }
}
```

#### 1.4 회문 순열

```cpp
bool ans = false;
void permutation(string str, int size) {
    if (str.size() == size) {
        int s = 0;
        int e = size() - 1;
        for (int i=0; i<size()/2; ++i) {
            if (str[s] != str[e]) return;
            s++;
            e--;
        }
    }

    // 순열
}
bool solve(string input) {
    input.replaceAll("", "");


}
```

문자열 길이가 짝수이면, 해당 문자열에 존재하는 모든 문자의 개수가 각각 짝수개여야 한다. 반대로 홀수이면 하나의 문자의 개수는 홀수일 수 있지만, 나머지는 반드시 개수가 짝수여야 한다.

```java
boolean isPermutationOfPalindrome(String phrase) {
    int[] table = buildCharFrequencyTable(phrase);
    return checkMaxOneOdd(table);
}

/* 홀수 문자가 한 개 이상 존재하는지 확인한다. */
boolean checkMaxOneOdd(int[] table) {
    boolean foundOdd = false;
    for (int count : table) {
        if (count % 2 == 1) {
            if (foundOdd) {
                return false;
            }
            foundOdd = true;
        }
    }
    return true;
}

/* 각 문자에 숫자를 대응시킨다. a->0, b->1, c->2 등등 
 * 대소문자 구분이 없고, 문자가 아닌 경우에는 -1로 대응시킨다. */
 int getCharNumber(Character c) {
     int a = Character.getNumericValue('a');
     int z = Character.getNumericValue('z');
     int val = Character.getNumericValue(c);
     if (a <= val && val <= z) {
         return val - a;
     }

     return -1;
 }

 /* 각 문자가 몇 번 등장했는지 센다. */
 int[] buildCharFrequencyTable(String phrase) {
     int[] table = new int[Character.getNumericValue('z') - Character.getNumericValue('a') + 1];
     for (char c : phrase.toCharArray()) {
         int x = getCharNumber(c);
         if (x != -1) {
             Table[x]++;
         }
     }
     return table;
 }
 ```

#### 1.5 하나 빼기
완전 탐색은 매우 느리다. 생각만해보고 구현은 하지말자.

```java
boolean oneEditAway(String first, String second) {
    if (first.length() == second.length()) {
        return oneEditReplace(first, second);
    } else if (first.length() + 1 == second.length()) {
        return oneEditInsert(first, second);
    } else if (first.length() -1 == second.length()) {
        return oneEditInsert(second, first);
    }

    return false;
}

boolean oneEditReplace(String s1, String s2) {
    boolean foundDifference = false;
    for (int i=0; i<s1.length(); ++i) {
        if (s1.charAt(i) != s2.charAt(i)) {
            if (foundDifference) {
                return false;
            }
            foundDifference = true;
        }
    }
    return true;
}
    
/* s1에 문자 하나를 삽입해서 s2를 만들 수 있는지 확인 
 * s1, s2 중 길이가 짧은 문자열이 s1이어야 한다.   */
boolean oneEditInsert(String s1, String s2) {
    int index1 = 0;
    int index2 = 0;
    while (index2 < s2.length() && index1 < s1.length()) {
        if (S1.charAt(index1) != s1.charAt(index2)) {
            if (index1 != index2) {
                return false;
            }
            index2++;
        } else {
            index1++;
            index2++;
        }
    }
    return true;
}
```

`oneEditReplace()`와 `oneEditInsert()`는 하나의 메서드로 합칠 수 있다. 이 두 방법 중 뭐가 좋다고는 답이 없으나 하나의 메서드로 합치는 것이 중복을 제거하였고 유지보수하기가 좋다. 하지만 첫 번째 방법이 가독성이 좋은 경우도 있다.

```java
boolean oneEditAway(String first, String second) {
    /* 길이 체크 */
    if (Math.abs(first.length() - second.length()) > 1) {
        return false;
    }

    /* 길이가 짧은 문자열과 긴 문자열 찾기 */
    String s1 = first.length() < second.length() ? first : second;
    String s2 = first.length() > second.length() ? first : second;

    int index1 = 0;
    int index2 = 0;
    boolean foundDifference = false;
    while (index2 < s2.length() && index1 < s1.length()) {
        if (s1.charAt(index1) != s2.charAt(index2)) {
            /* 반드시 첫 번째로 다른 문자어야 한다. */
            if (foundDifference) return false;
            foundDifference = true;
            if (s1.length() == s2.length()) { // 교체의 경우 짧은 문자열의 포인터를 증가
                index1++;
            }
        } else {
            index1++;  // 동일하다면 짧은 문자열의 포인터를 증가
        }
        index2++;  // 긴 문자열의 포인터는 언제나 증가
    }
    return true;
}
```

#### 1.6 문자열 압축

```cpp
string solve(string input) {
    string compressed;

    for (int i=0; i<input.size()-1; ++i) {
        int len = 1;
        for (int j=i+1; j<input.size(); ++i) {
            if (input[i] == input[j]) {
                len++;
            } else {
                i = j-1;
                compressed.push_back(input[i]);
                compressed.push_back(len);
                break;
            }
        }
    }

    if (compressed.size() > input.size()) return input;
    else return compressed;
}
```

```java
String compressBad(String str) {
    String compressedString = "";
    int countConsecutive = 0;
    for (int i=0; i<str.length(); ++i) {
        countConsecutive++;

        /* 다음 문자와 현재 문자가 같지 않다면 현재 문자를 결과 문자열에 추가해준다. */
        if (i + 1 >= str.length() || str.charAt(i) != str.charAt(i + 1)) {
            compressedString += "" + str.charAt(i) + countConsecutive;
            countConsecutive = 0;
        }
    }

    return compressedString.length() < str.length() ? compressedString : str;
}
```

문자열을 더하는 로직에서 단순히 String을 사용하면 O(n^2)의 시간이 걸린다.

```java
String compress(String str) {
    StringBuilder compressed = new StringBuilder();
    int countConsecutive = 0;
    for (int i=0; i<str.length(); ++i) {
        countConsecutive++;

        if (i + 1 >= str.length() || str.charAt(i) != str.charAt(i + 1)) {
            compressed.append(str.charAt(i));
            compressed.append(countConsecutive);
            countConsecutive = 0;
        }
    }

    return compressed.length() > str.length() ? str : compressed.toString();
}
```

#### 1.7 행렬 회전

```java
boolean rotate(int[][] matrix) {
    if (matrix.length == 0 || matrix.length != matrix[0].length) return false;

    int n = matrix.length;
    for (int layer = 0; layer < n/2; ++layer) {
        int first = layer;
        int last = n - 1 - layer;
        for (int i=first; i<last; ++i) {
            int offset = i - first;
            int top = matrix[first][i];  // 윗 부분을 저장해 놓는다.

            // 왼쪽 -> 오른쪽
            matrix[first][i] = matrix[last-offset][first];

            // 아래쪽 -> 왼쪽
            matrix[last-offset][first] = matrix[last][last-offset];

            // 오른쪽 -> 아래쪽
            matrix[last][last-offset] = matrix[i][last];

            // 위쪽 -> 오른쪽
            matrix[i][last] = top;  // 오른쪽 <- 미리 저장해 놓은 top
        }
    }

    return true;
}
```

#### 1.8 0 행렬
이 문제는 실수하기 좋은 문제이다. 단순히 for문으로 순서대로 0을 찾고 바로 행렬을 변경해버리면 그 이후에 바뀐 0값을 또 인식하고 만다. 그래서 최초의 0의 위치를 저장해 놓는 것이 중요하다.

```java
void setZeros(int[][] matrix) {
    boolean[] row = new boolean[matrix.length];
    boolean[] column = new boolean[matrix[0].length];

    // 값이 0인 행과 열의 인덱스를 저장한다.
    for (int i=0; i<matrix.length; ++i) {
        for (int j=0; j<matrix[0].length; ++j) {
            if (matrix[i][j] == 0) {
                row[i] = true;
                column[j] = true;
            }
        }
    }

    // 행의 원소를 전부 0으로 바꾼다.
    for (int i=0; i<row.length; ++i) {
        if (row[i]) nullifyRow(matrix, i);
    }

    // 열의 원소를 전부 0으로 바꾼다.
    for (int i=0; i<column.length; ++i) {
        if (column[i]) nullifyColumn(matrix, i);
    }
}

void nullifyRow(int[][] matrix, int row) {
    for (int i=0; i<matrix[0].length; ++i) {
        matrix[row][i] = 0;
    }
}

void nullifyColumn(int[][] matrix, int col) {
    for (int i=0; i<matrix.length; ++i) {
        matrix[i][col] = 0;
    }
}
```

#### 1.9 문자열 회전

```java
boolean isRotation(String s1, String s2) {
    int len = s1.length();
    /* s1과 s2의 길이가 같고 빈 문자열이 아닌지 확인 */
    if (len == s2.length() && len > 0) {
        /* s1과 s1을 합친 결과를 새로운 버퍼에 저장 */
        String s1s1 = s1 + s1;
        return isSubstring(s1s1, s2);
    }

    return false;
}
```

### 연결리스트
#### 2.1 중복 없애기

```java
void deleteDups(LinkedListNode n) {
    HashSet set = new HashSet();
    LinkedListNode previous = null;
    while (n != null) {
        if (set.contains(n.data)) {
            previous.next = n.next;
        } else {
            set.add(n.data);
            previous = n;
        }
        n = n.next;
    }
}
```

- 버퍼가 없을 때

```java
void deleteDups(LinkedListNode head) {
    LinkedListNode current = head;
    while (current != null) {
        /* 값이 같은 다음 노드들을 모두 제거한다. */
        LinkedListNode runner = current;
        while (runner.next != null) {
            if (runner.next.data == current.data) {
                runner.next = runner.next.next;
            } else {
                runner = runner.next;
            }
        }
        current = current.next;
    }
}
```

#### 2.2 뒤에서 k번째 원소 구하기

```java
int findKth(LinkedListNode list, int k) {
    int size = getSize(list);
    int ans = 0;
    for (int i=0; i<size-(k-1); ++i) {
        ans = list.data;
        list = list.next;
    }

    return ans;
}

int getSize(LinkedListNode list) {
    int size = 0;
    LinkedListNode temp = list;
    while (temp != null) {
        size++;
        temp = temp.next;
    }

    return size;
}
```

```java
int printKthToLast(LinkedListNode head, int k) {
    if (head == null) {
        return 0;
    }
    int index = printKthToLast(head.next, k) + 1;
    if (index == k) {
        System.out.println(head.data);
    }
    return index;
}
```

#### 2.4 분할

- stable

```java
LinkedListNode partition(LinkedListNode node, int x) {
    LinkedListNode beforeStart = null;
    LinkedListNode beforeEnd = null;
    LinkedListNode afterStart = null;
    LinkedListNode afterEnd = null;

    while (node != null) {
        LinkedListNode next = node.next;
        node.next = null;
        if (node.data < x) {
            if (beforeStart == null) {
                beforeStart = node;
                beforeEnd = beforeStart;
            } else {
                beforeEnd.next = node;
                beforeEnd = node;
            }
        } else {
            if (afterStart == null) {
                afterStart = node;
                afterEnd = afterStart;
            } else {
                afterEnd.next = node;
                afterEnd = node;
            }
        }
        node = next;
    }

    if (beforeStart == null) {
        return afterStart;
    }

    beforeEnd.next = afterStart;
    return beforeStart;
}
```

- unstable

```java
LinkedListNode partition(LinkedListNode node, int x) {
    LinkedListNode head = node;
    LinkedListNode tail = node;

    while (node != null) {
        LinkedListNode next = node.next;
        if (node.data < x) {
            node.next = head;
            head = node;
        } else {
            tail.next = node;
            tail = node;
        }
        node =next;
    }
    tail.next = null;
    return head;
}
```

#### 2.5 리스트의 합

- 자릿수 반대 리스트

```java
LinkedListNode addLists(LinkedListNode l1, LinkedListNode l2, int carry) {
    if (l1 == null && l2 == null && carry == 0) {
        return null;
    }

    LinkedListNode result = new LinkedListNode();
    int value = carry;
    if (l1 != null) {
        value += l1.data;
    }
    if (l2 != null) {
        value += l2.data;
    }

    result.data = value % 10;

    if (l1 != null || l2 != null) {
        LinkedListNode more = addLists(l1 == null ? null : l1.next,
        l2 == null ? null : l2.next,
        value > 10 ? 1 : 0);

        result.setNext(more);
    }

    return result;
}
```

- 정상적인 방향 리스트 더하기

```java
class PartialSum {
    public LinkedListNode sum = null;
    public int carry = 0;
}

LinkedListNode addLists(LinkedListNode l1, LinkedListNode l2) {
    int len1 = length(l1);
    int len2 = length(l2);

    if (len1 < len2) {
        l1 = padList(l1, len2 - len1);
    } else {
        l2 = padList(l2, len1 - len2);
    }

    PartialSum sum = addListsHelper(l1, l2);

    if (sum.carry == 0) {
        return sum.sum;
    } else {
        LinkedListNode result = insertBefore(sum.sum, sum.carry);
        return result;
    }
}

PartialSum addListsHelper(LinkedListNode l1, LikedListNode l2) {
    if (l1 == null && l2 == null) {
        PartialSum sum = new PartialSum();
        return sum;
    }

    PartialSum sum = addListsHelper(l1.next, l2.next);

    int val = sum.carry + l1.data + l2.data;

    LinkedListNode full_result = insertBefore(sum.sum, val % 10);

    sum.sum = full_result;
    sum.carry = val / 10;
    return sum;
}

LinkedListNode padList(LinkedListNode l, int padding) {
    LinkedListNode head = l;
    for (int i=0; i<padding; ++i) {
        head = insertBefore(head, 0);
    }
    return head;
}

LinkedListNode insertBefore(LinkedListNode list, int data) {
    LinkedListNode node = new LinkedListNode(data);
    if (list != null) {
        node.next = list;
    }
    return node;
}
```

#### 2.6 회문

- 뒤집어서 비교한다.

```java
boolean isPalindrome(LinkedListNode head) {
    LinkedListNode reversed = reverseAndClone(head);
    return isEqual(head, reversed);
}

LinkedListNode reverseAndClone(LinkedListNode node) {
    LinkedListNode head = null;
    while (node != null) {
        LinkedListNode n = new LinkedListNode(node.data);
        n.next = head;
        head = n;
        node = node.next;
    }
    return head;
}

boolean isEqual(LinkedListNode one, LinkedListNode two) {
    while (one != null && two != null) {
        if (one.data != two.data) {
            return false;
        }
        one = one.next;
        two = two.next;
    }
    return one == null && two == null;
}
```

- 순환적 접근법

```java
boolean isPalindrome(LinkedListNode head) {
    LinkedListNode fast = head;
    LinkedListNode slow = head;

    Stack stack = new Stack;
    while (fast != null && fast.next != null) {
        stack.push(slow.data);
        slow = slow.next;
        fast = fast.next.next;
    }

    if (fast != null) {
        slow = slow.next;
    }

    while (slow != null) {
        int top = stack.pop().intValue();
        if (top != slow.data) {
            return false;
        }
        slow = slow.next;
    }
    return true;
}

- 재귀적 접근법

```java
```

#### 2.8 루프 발견

```java
LinkedListNode FindBeginning(LinkedList head) {
    LinkedListNode slow = head;
    LinkedListNode fast = head;

    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) {
            break;
        }
    }

    if (fast == null || fast.next == null) {
        return null;
    }

    slow = head;
    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }

    return fast;
}
```

### 스택과 큐
#### 3.1 한 개로 세 개

- 고정 크기 할당

```java
class FixedMultiStack {
    private int numberOfStacks = 3;
    private int stackCapacity;
    private int[] values;
    private int[] sizes;
    // ...
}
```

- 유연한 공간 할당

#### 3.2 스택 Min

- 스택 상태마다 최소값 저장해놓기
- 스택 2개 쓰기

```java
class Stack {
    private int size;
    private int buffer[];
    private int minValue;

    public Stack() {
        this.size = 0;
        this.minValue = Integer.MAX_VALUE;
    }

    public void push(int value) {
        buffer[size++] = value;
        this.minValue = this.minValue < value ? this.minValue : value;
    }

    public int pop() {
        int popValue = buffer[size - 1];
        if (popValue == this.minValue) {
            //
        }
        size--;
        return popValue;
    }

    public int min() {
        return this.minValue;
    }
}
```

#### 3.3 접시 무더기

```java
class SetOfStacks {
    private List<Stack<Integer>> stacks = new ArrayList<>();
    private int size;
    private int standard;
    private int numOfStack;

    public SetOfStacks(int standard) {
        this.size = 0;
        this.standard = standard;
        this.numOfStack = 1;
    }

    public void push(int value) {
        if ((size + 1) % standard == 0) {
            stacks.add(new Stack<Integer>());
            numOfStack++;
        }
        stacks.get(numOfStack - 1).add(value);
    }

    public int pop() {
        if (size == 0) {
            throw new exception();
        }
        int popValue = stacks.get(numOfStack - 1).pop();
        size--;
        if (size % standard == 0) {
            numOfStack--;
        }
        return popValue;
    }
}
```

#### 3.3 스택으로 큐

```java
class MyQueue {
    private Stack<Integer> inStack;
    private Stack<Integer> outStack;
    private int size;

    public MyQueue() {
        this.size = 0;
    }

    public void push(int value) {
        this.size++;
        inStack.push(value);
    }

    public int pop() {
        if (this.size == 0) {
            throw new 
        }

        while(!inStack.isEmpty()) {
            outStack.push(inStack.pop());
        }

        int popValue = outStack.pop();

        while(!outStack.isEmpty()) {
            inStack.push(outStack.pop());
        }

        this.size--;

        return popValue;
    }
}
```

```java
public class MyQueue {
    Stack stackNewest, stackOldest;

    public MyQueue() {
        stackNewest = new Stack();
        stackOldest = new Stack();
    }

    public int size() {
        return stackNewest.size() + stackOldest.size();
    }

    public void add(T value) {
        stackNewest.push(value);
    }

    private void shiftStacks() {
        if (stackOldest.isEmpty()) {
            while (!stackNewest.isEmpty()) {
                stackOldest.push(stackNewest.pop());
            }
        }
    }

    public T peek() {
        shiftStacks();
        return stackOldest.peek();
    }

    public T pop() {
        shiftStacks();
        return stackOldest.pop();
    }
}
```

#### 3.5 스택 정렬

```java
class SmallestStack {
    private Stack minStack, stack;
    private int size;

    public SmallestStack() {
        this.size = 0;
        minStack = new Stack();
        stack = new Stack();
    }

    public void push(T value) {
        if (this.size == 0) {
            minStack.push(value);
        } else {
            T currentMinValue = minStack.peek();
            if (currentMinValue > value) {
                minStack.pop();
                minStack.push(value);
                stack.push(currentMinValue);
            } else {
                stack.push(value);
            }
        }
    }

    public T pop() {
        if (isEmpty()) {
            throw new 
        }

        T popValue = minStack.pop();

        T minValue = stack.pop();
        while (!stack.isEmpty()) {
            T value = stack.pop();
            minValue = Math.min(minValue, value);
        }

        while (!minStack.isEmpty()) {
            stack.push(minStack.pop());
        }

        minStack.push(minValue);
        this.size--;

        return popValue;
    }

    public boolean isEmpty() {
        return this.size == 0;
    }

    public T peek() {
        return minStack.peek();
    }
}
```

```java
void sort(Stack s) {
    Stack r = new Stack();
    while (!s.isEmpty()) {
        int tmp = s.pop();
        while (!r.isEmpty() && r.peek() > tmp) {
            s.push(r.pop());
        }
        r.push(tmp);
    }

    while (!r.isEmpty()) {
        s.push(r.pop());
    }
}
```

### 트리와 그래프 해법
#### 4.1 노드 사이의 경로

- 인접행렬

```java
void dfs(boolean[][] graph, boolean[] visited, int node) {
    visited[node] = true;

    for (int i=0; i<graph[node].length; ++i) {
        if (graph[node][i] && !visited[i]) {
            dfs(graph, visited, i);
        }
    }
}

void bfs(boolean[][] graph, boolean[] visited, int node) {
    Deque<Integer> q = new ArrayDeque();

    visited[node] = true;
    q.push(node);
    while (!q.isEmpty()) {
        int first = q.poll();

        for (int i=0; i<graph[first].length; ++i) {
            if (graph[first][i] && !visited[i]) {
                visited[i] = true;
                q.push(i);
            }
        }
    }
}

boolean hasPath(boolean[][] graph, int n1, int n2) {
    boolean[] visited = new boolean[graph[0].length];
    dfs(graph, visited, n1);
    // bfs(graph, visited, n1);

    return visited[n2];
}
```

#### 4.2 최소 트리

```java
TreeNode createMinimalBST(int array[]) {
    return createMinimalBST(array, 0, array.length-1);
}

TreeNode createMinimalBST(int arr[], int start, int end) {
    if (end < start) {
        return null;
    }

    int min = (start + end) / 2;
    TreeNode n = new TreeNode(arr[mid]);
    n.left = createMinimalBST(arr, start, mid - 1);
    n.right = createMinimalBST(arr, mid + 1, end);
    return n;
}
```

#### 4.3 깊이의 리스트

```java
void createLevelLinkedList(TreeNode root, ArrayList<LinkedList<TreeNode>> lists, int level) {
    if (root == null) return;

    LinkedList list = null;
    if (lists.size() == level) {
        list = new LinkedList();
        lists.add(list);
    } else {
        list = lists.get(level);
    }
    list.add(root);
    createLevelLinkedList(root.left, lists, level + 1);
    createLevelLinkedList(root.right, lists, level + 1);
}

ArrayList<LinkedList<TreeNode>> createLevelLinkedList(TreeNode root) {
    ArrayList<LinkedList<TreeNode>> lists = new ArrayList<>();
    createLevelLinkedList(root, lists, 0);
    return lists;
}
```

```java
ArrayList<LinkedList<TreeNode>> createLevelLinkedList(TreeNode root) {
    LinkedList current = new LinkedList();
    if (root != null) {
        current.add(root);
    }

    while (current.size() > 0) {
        result.add(current);
        LinkedList parents = current;
        current = new LinkedList();
        for (TreeNode parent : parents) {
            if (parent.left != null) {
                current.add(parent.left);
            }
            if (parent.right != null) {
                current.add(parent.right);
            }
        }
    }
    return result;
}
```

#### 4.4 균형 확인

```java
int getHeight(TreeNode root) {
    if (root == null) return -1;
    return Math.max(getHeight(root.left), getHeight(root.right)) + 1;
}

boolean isBalanced(TreeNode root) {
    if (root == null) return true;

    int heightDiff = getHeight(roo.left) - getHeight(root.right);
    if (Math.abs(heightDiff) > 1) {
        return false;
    } else {
        return isBalanced(root.left) && isBalanced(root.right);
    }
}
