# 이펙티브 자바 3판


## 목차
### 객체 생성과 파괴
- [Item1. 생성자 대신 정적 팩토리 메서드를 고려하라.](#item1-생성자-대신-정적-팩토리-메서드를-고려하라)
- [Item2. 생성자에 매개변수가 많다면 빌더를 고려하라.](#item2-생성자에-매개변수가-많다면-빌더를-고려하라)
- [Item3. private 생성자나 열거 타입으로 싱글턴임을 보증하라.](#item3-private-생성자나-열거-타입으로-싱글턴임을-보증하라)
- [Item4. 인스턴스화를 막으려거든 private 생성자를 사용하라.](#item4-인스턴스화를-막으려거든-private-생성자를-사용하라)
- [Item5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라.](#item5-자원을-직접-명시하지-말고-의존-객체-주입을-사용하라)
- [Item6. 불필요한 객체 생성을 피하라.](#item6-불필요한-객체-생성을-피하라)
- [Item7. 다 쓴 객체 참조를 해제하라.](#item7-다-쓴-객체-참조를-해제하라)
- [Item8. finalizer와 cleaner 사용을 피하라.](#item8-finalizer와-cleaner-사용을-피하라)
- [Item9. try-finally보다는 try-with-resources를 사용하라.](#item9-tryfinally보다는-trywithresources를-사용하라)

### 모든 객체의 공통 메서드
- [Item10. equals는 일반 규약을 지켜 재정의하라.](#item10-equals는-일반-규약을-지켜-재정의하라)
- [Item11. equals를 재정의하려거든 hashcode도 재정의하라.](#item11-equals를-재정의하려거든-hashcode도-재정의하라)
- [Item12. toString을 항상 재정의하라.](#item12-tostring을-항상-재정의하라)
- [Item13. clone 재정의는 주의해서 진행하라.](#item13-clone-재정의는-주의해서-진행하라)
- [Item14. Comparable을 구현할지 고려하라.](#item14-comparable을-구현할지-고려하라)

### 클래스와 인터페이스
- [Item15. 클래스와 멤버의 접근 권한을 최소화하라.](#item15-클래스와-멤버의-접근-권한을-최소화하라)
- [Item16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.](#item16-public-클래스에서는-public-필드가-아닌-접근자-메서드를-사용하라)
- [Item17. 변경 가능성을 최소화하라.](#item17-변경-가능성을-최소화하라)
- [Item18. 상속보다는 컴포지션을 사용하라.](#item18-상속보다는-컴포지션을-사용하라)
- [Item19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.](#item19-상속을-고려해-설계하고-문서화하라-그러지-않았다면-상속을-금지하라)
- [Item20. 추상 클래스보다는 인터페이스를 우선하라.](#item20-추상-클래스보다는-인터페이스를-우선하라)
- [Item21. 인터페이스는 구현하는 쪽을 생각해 설계하라.](#item21-인터페이스는-구현하는-쪽을-생각해-설계하라)
- [Item22. 인터페이스는 타입을 정의하는 용도로만 사용하라.](#item22-인터페이스는-타입을-정의하는-용도로만-사용하라)
- [Item23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라.](#item23-태그-달린-클래스보다는-클래스-계층구조를-활용하라)
- [Item24. 멤버 클래스는 되도록 static으로 만들라.](#item24-멤버-클래스는-되도록-static으로-만들라)
- [Item25. 톱레벨 클래스는 한 파일에 하나만 담으라.](#item25-톱레벨-클래스는-한-파일에-하나만-담으라)

### 제네릭
- [Item26. 로 타입은 사용하지 말라.](#item26-로-타입은-사용하지-말라)
- [Item27. 비검사 경고를 제거하라.](#item27-비검사-경고를-제거하라)
- [Item28. 배열보다는 리스트를 사용하라.](#item28-배열보다는-리스트를-사용하라)
- [Item29. 이왕이면 제네릭 타입으로 만들라.](#item29-이왕이면-제네릭-타입으로-만들라)
- [Item30. 이왕이면 제네릭 메서드로 만들라.](#item30-이왕이면-제네릭-메서드로-만들라)
- [Item31. 한정적 와일드카드를 사용해 API 유연성을 높이라.](#item31-한정적-와일드카드를-사용해-api-유연성을-높이라)
- [Item32. 제네릭과 가변인수를 함께 쓸 때는 신중하라.](#item32-제네릭과-가변인수를-함께-쓸-때는-신중하라)
- [Item33. 타입 안전 이종 컨테이너를 고려하라.](#item33-타입-안전-이종-컨테이너를-고려하라)

### 열거 타입과 애너테이션
- [Item34. int 상수 대신 열거 타입을 사용하라.](#item34-int-상수-대신-열거-타입을-사용하라)
- [Item35. ordinal 메서드 대신 인스턴스 필드를 사용하라.](#item35-ordinal-메서드-대신-인스턴스-필드를-사용하라)
- [Item36. 비트 필드 대신 EnumSet을 사용하라.](#item36-비트-필드-대신-enumset을-사용하라)
- [Item37. ordinal 인덱싱 대신 EnumMap을 사용하라.](#item37-ordinal-인덱싱-대신-enummap을-사용하라)
- [Item38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라.](#item38-확장할-수-있는-열거-타입이-필요하면-인터페이스를-사용하라)
- [Item39. 명명 패턴보다 애너테이션을 사용하라.](#item39-명명-패턴보다-애너테이션을-사용하라)
- [Item40. @Override 애너테이션을 일관되게 사용하라.](#item40-override-애너테이션을-일관되게-사용하라)
- [Item41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라.](#item41-정의하려는-것이-타입이라면-마커-인터페이스를-사용하라)

### 람다와 스트림
- [Item42. 익명 클래스보다는 람다를 사용하라.](#item42-익명-클래스보다는-람다를-사용하라)
- [Item43. 람다보다는 메서드 참조를 사용하라.](#item43-람다보다는-메서드-참조를-사용하라)
- [Item44. 표준 함수형 인터페이스를 사용하라.](#item44-표준-함수형-인터페이스를-사용하라)
- [Item45. 스트림은 주의해서 사용하라.](#item45-스트림은-주의해서-사용하라)
- [Item46. 스트림에서는 부작용 없는 함수를 사용하라.](#item46-스트림에서는-부작용-없는-함수를-사용하라)
- [Item47. 반환 타입으로는 스트림보다는 컬렉션이 낫다.](#item47-반환-타입으로는-스트림보다는-컬렉션이-낫다)
- [Item48. 스트림 병렬화는 주의해서 적용하라.](#item48-스트림-병렬화는-주의해서-적용하라)

### 메서드
- [Item49. 매개변수가 유효한지 검사하라.](#item49-매개변수가-유효한지-검사하라)
- [Item50. 적시에 방어적 복사본을 만들라.](#item50-적시에-방어적-복사본을-만들라)
- [Item51. 메서드 시그니처를 신중히 설계하라.](#item51-메서드-시그니처를-신중히-설계하라)
- [Item52. 다중정의는 신중히 사용하라.](#item52-다중정의는-신중히-사용하라)
- [Item53. 가변인수는 신중히 사용하라.](#item53-가변인수는-신중히-사용하라)
- [Item54. null이 아닌, 빈 컬렉션이나 배열을 반환하라.](#item54-null이-아닌-빈-컬렉션이나-배열을-반환하라)
- [Item55. 옵셔널 반환은 신중히 하라.](#item55-옵셔널-반환은-신중히-하라)
- [Item56. 공개된 API 요소에는 항상 문서화 주석을 작성하라.](#item56-공개된-api-요소에는-항상-문서화-주석을-작성하라)

### 일반적인 프로그래밍 원칙
- [Item57. 지역변수의 범위를 최소화하라.](#item57-지역변수의-범위를-최소화하라)
- [Item58. 전통적인 for 문보다는 for-each 문을 사용하라.](#item58-전통적인-for-문보다는-foreach-문을-사용하라)
- [Item59. 라이브러리를 익히고 사용하라.](#item59-라이브러리를-익히고-사용하라)
- [Item60. 정확한 답이 필요하다면 float와 double은 피하라.](#item60-정확한-답이-필요하다면-float와-double은-피하라)
- [Item61. 박싱된 기본 타입보다는 기본 타입을 사용하라.](#item61-박싱된-기본-타입보다는-기본-타입을-사용하라)
- [Item62. 다른 타입이 적절하다면 문자열 사용을 피하라.](#item62-다른-타입이-적절하다면-문자열-사용을-피하라)
- [Item63. 문자열 연결은 느리니 주의하라.](#item63-문자열-연결은-느리니-주의하라)
- [Item64. 객체는 인터페이스를 사용해 참조하라.](#item64-객체는-인터페이스를-사용해-참조하라)
- [Item65. 리플렉션보다는 인터페이스를 사용하라.](#item65-리플렉션보다는-인터페이스를-사용하라)
- [Item66. 네이티브 메서드는 신중히 사용하라.](#item66-네이티브-메서드는-신중히-사용하라)
- [Item67. 최적화는 신중히 하라.](#item67-최적화는-신중히-하라)
- [Item68. 일반적으로 통용되는 명명 규칙을 따르라.](#item68-일반적으로-통용되는-명명-규칙을-따르라)

### 에외
- [Item69. 예외는 진짜 예외 상황에만 사용하라.](#item69-예외는-진짜-예외-상황에만-사용하라)
- [Item70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라.](#item70-복구할-수-있는-상황에는-검사-예외를-프로그래밍-오류에는-런타임-예외를-사용하라)
- [Item71. 필요 없는 검사 예외 사용은 피하라.](#item71-필요-없는-검사-예외-사용은-피하라)
- [Item72. 표준 예외를 사용하라.](#item72-표준-예외를-사용하라)
- [Item73. 추상화 수준에 맞는 예외를 던지라.](#item73-추상화-수준에-맞는-예외를-던지라)
- [Item74. 메서드가 던지는 모든 예외를 문서화하라.](#item74-메서드가-던지는-모든-예외를-문서화하라)
- [Item75. 예외의 상세 메시지에 실패 관련 정보를 담으라.](#item75-예외의-상세-메시지에-실패-관련-정보를-담으라)
- [Item76. 가능한 한 실패 원자적으로 만들라.](#item76-가능한-한-실패-원자적으로-만들라)
- [Item77. 예외를 무시하지 말라.](#item77-예외를-무시하지-말라)

### 동시성
- [Item78. 공유 중인 가변 데이터는 동기화해서 사용하라.](#item78-공유-중인-가변-데이터는-동기화해서-사용하라)
- [Item79. 과도한 동기화는 피하라.](#item79-과도한-동기화는-피하라)
- [Item80. 스레드보다는 실행자, 태스크, 스트림을 애용하라.](#item80-스레드보다는-실행자-태스크-스트림을-애용하라)
- [Item81. wait와 notify보다는 동시성 유틸리티를 애용하라.](#item81-wait와-notify보다는-동시성-유틸리티를-애용하라)
- [Item82. 스레드 안정성 수준을 문서화하라.](#item82-스레드-안정성-수준을-문서화하라)
- [Item83. 지연 초기화는 신중히 사용하라.](#item83-지연-초기화는-신중히-사용하라)
- [Item84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라.](#item84-프로그램의-동작을-스레드-스케줄러에-기대지-말라)

### 직렬화
- [Item85. 자바 직렬화의 대안을 찾으라.](#item85-자바-직렬화의-대안을-찾으라)
- [Item86. Serializable을 구현할지는 신중히 결정하라.](#item86-serializable을-구현할지는-신중히-결정하라)
- [Item87. 커스텀 직렬화 형태를 고려해보라.](#item87-커스텀-직렬화-형태를-고려해보라)
- [Item88. readObject 메서드는 방어적으로 작성하라.](#item88-readobject-메서드는-방어적으로-작성하라)
- [Item89. 인스턴수 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라.](#item89-인스턴수-수를-통제해야-한다면-readresolve보다는-열거-타입을-사용하라)
- [Item90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라.](#item90-직렬화된-인스턴스-대신-직렬화-프록시-사용을-검토하라)


## Item1. 생성자 대신 정적 팩토리 메서드를 고려하라.
- 클래스는 생성자와는 별도로 정적 팩토리 메서드(static factory method)를 제공할 수 있다.
- 정적 팩토리 메서드는 디자인 패턴의 팩토리 메서드와 다르다.

### 정적 팩토리 메서드의 장점
- **이름을 가질 수 있다.**
    - 메서드의 이름을 잘 지으면 어떤 특성을 가진 객체인지 쉽게 묘사할 수 있다.
    - 생성자는 하나의 시그니처만에 종속한다. 하나의 시그니처로 여러 동작을 원하면 정적 팩토리 메서드를 쓸 수 있다.
- **호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.**
    - 불변 클래스와 같이 미리 만들어논 인스턴스를 재활용할 수 있다.(불필요한 객체 생성을 막음)
    - 인스턴스 통제
        - 싱글톤
        - 인스턴스화 불가
        - 인스턴스가 하나임을 보장(대표적으로 Enum은 인스턴스가 하나임을 보장함)
        - ...
- **반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.**
    - 반환할 객체의 클래스를 자유롭게 선택할 수 있다.
- **입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.**
    - 반환 타입의 하위 타입이기만 하면 어떤 클래스를 반환하든 상관없다.
- **정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.**
    - 이런 유연함은 서비스 제공자 프레임워크를 만드는 근간이다.(대표적인 서비스 제공자 프레임워크는 JDBC)
        - 제공자는 서비스의 구현체
    - 서비스 제공자 프레임워크는 3개의 핵심 컴포넌트로 이루어진다.
        - 서비스 인터페이스: 구현체의 동작 정의(JDBC `Connection`)
        - 제공자 등록 API: 제공자가 구현체를 등록할 때 사용(JDBC `DriverManager.registerDriver`)
        - **서비스 접근 API**: 클라이언트가 서비스의 인터페이스를 얻을 때(정적 팩토리 사용, JDBC `DriverManager.getConnection`)
        - 서비스 제공자 인터페이스: 팩토리 객체에 대한 설명(핵심 컴포넌트는 아님)
    - 서비스 제공자 프레임워크는 정적 팩토리 메서드뿐 아니라 여러 패턴이 있다.(DI, Bridge Pattern 등)

### 정적 팩토리 메서드의 단점
- **상속을 하려면 public 또는 protected 생성자가 필요하여 정적 팩토리 메서드만으로는 하위 클래스를 만들 수 없다.**
- **정적 팩토리 메서드는 개발자가 찾기 어렵다.**

### 정적 팩토리 메서드에서 자주 사용되는 명명 방식
- `from`: 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
- `of`: 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
- `valueOf`: `from`과 `of`의 더 자세한 버전
- `instance` or `getInstance`: 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장하지는 않는다.
- `create` or `newInstance`: 기능은 위와 같지만, 매번 새로운 인스턴스를 생성해 반환함을 보장해야한다.
- `getType`: `getInstance`와 같으나, 생성할 클래스가 아닌 다른 클래스에 팩토리 메서드를 정의할 때 쓴다.(Type은 반환할 객체 타입)
- `newType`: `newInstance` + `getType`
- `type`: 간결한 버전


## Item2. 생성자에 매개변수가 많다면 빌더를 고려하라.
- 정적 팩토리와 생성자는 매개변수가 많을수록 가독성이 떨어진다.
- 필수 매개변수와 선택 매개변수가 나눠져있을 때, 이전에는 점층적 생성자 패턴을 사용했다.(생성자 오버로딩)
- 점층적 생성자 패턴 역시 매개변수가 많아지면 가독성이 떨어진다.
    - 매개변수의 값이 어떤 상태변수를 나타내는지 알기 어렵다.
    - 순서를 알기 어렵다.
- `setter`를 가지는 자바빈즈는 생성자가 필요없어 매개변수에 대한 문제점은 없지만, 객체지향 관점에서 캡슐화가 깨진다.
- 문제점을 해결할 수 있는 좋은 방법 중 하나는 **빌더 패턴**이다.


## Item3. private 생성자나 열거 타입으로 싱글턴임을 보증하라.
## Item4. 인스턴스화를 막으려거든 private 생성자를 사용하라.
## Item5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라.
## Item6. 불필요한 객체 생성을 피하라.
## Item7. 다 쓴 객체 참조를 해제하라.
## Item8. finalizer와 cleaner 사용을 피하라.
## Item9. try-finally보다는 try-with-resources를 사용하라.
## Item10. equals는 일반 규약을 지켜 재정의하라.
## Item11. equals를 재정의하려거든 hashcode도 재정의하라.
## Item12. toString을 항상 재정의하라.
## Item13. clone 재정의는 주의해서 진행하라.
## Item14. Comparable을 구현할지 고려하라.
## Item15. 클래스와 멤버의 접근 권한을 최소화하라.
## Item16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.
## Item17. 변경 가능성을 최소화하라.
## Item18. 상속보다는 컴포지션을 사용하라.
## Item19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라.
## Item20. 추상 클래스보다는 인터페이스를 우선하라.
## Item21. 인터페이스는 구현하는 쪽을 생각해 설계하라.
## Item22. 인터페이스는 타입을 정의하는 용도로만 사용하라.
## Item23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라.
## Item24. 멤버 클래스는 되도록 static으로 만들라.
## Item25. 톱레벨 클래스는 한 파일에 하나만 담으라.
## Item26. 로 타입은 사용하지 말라.
## Item27. 비검사 경고를 제거하라.
## Item28. 배열보다는 리스트를 사용하라.
## Item29. 이왕이면 제네릭 타입으로 만들라.
## Item30. 이왕이면 제네릭 메서드로 만들라.
## Item31. 한정적 와일드카드를 사용해 API 유연성을 높이라.
## Item32. 제네릭과 가변인수를 함께 쓸 때는 신중하라.
## Item33. 타입 안전 이종 컨테이너를 고려하라.
## Item34. int 상수 대신 열거 타입을 사용하라.
## Item35. ordinal 메서드 대신 인스턴스 필드를 사용하라.
## Item36. 비트 필드 대신 EnumSet을 사용하라.
## Item37. ordinal 인덱싱 대신 EnumMap을 사용하라.
## Item38. 확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라.
## Item39. 명명 패턴보다 애너테이션을 사용하라.
## Item40. @Override 애너테이션을 일관되게 사용하라.
## Item41. 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라.
## Item42. 익명 클래스보다는 람다를 사용하라.
## Item43. 람다보다는 메서드 참조를 사용하라.
## Item44. 표준 함수형 인터페이스를 사용하라.
## Item45. 스트림은 주의해서 사용하라.
## Item46. 스트림에서는 부작용 없는 함수를 사용하라.
## Item47. 반환 타입으로는 스트림보다는 컬렉션이 낫다.
## Item48. 스트림 병렬화는 주의해서 적용하라.
## Item49. 매개변수가 유효한지 검사하라.
## Item50. 적시에 방어적 복사본을 만들라.
## Item51. 메서드 시그니처를 신중히 설계하라.
## Item52. 다중정의는 신중히 사용하라.
## Item53. 가변인수는 신중히 사용하라.
## Item54. null이 아닌, 빈 컬렉션이나 배열을 반환하라.
## Item55. 옵셔널 반환은 신중히 하라.
## Item56. 공개된 API 요소에는 항상 문서화 주석을 작성하라.
## Item57. 지역변수의 범위를 최소화하라.
## Item58. 전통적인 for 문보다는 for-each 문을 사용하라.
## Item59. 라이브러리를 익히고 사용하라.
## Item60. 정확한 답이 필요하다면 float와 double은 피하라.
## Item61. 박싱된 기본 타입보다는 기본 타입을 사용하라.
## Item62. 다른 타입이 적절하다면 문자열 사용을 피하라.
## Item63. 문자열 연결은 느리니 주의하라.
## Item64. 객체는 인터페이스를 사용해 참조하라.
## Item65. 리플렉션보다는 인터페이스를 사용하라.
## Item66. 네이티브 메서드는 신중히 사용하라.
## Item67. 최적화는 신중히 하라.
## Item68. 일반적으로 통용되는 명명 규칙을 따르라.
## Item69. 예외는 진짜 예외 상황에만 사용하라.
## Item70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라.
## Item71. 필요 없는 검사 예외 사용은 피하라.
## Item72. 표준 예외를 사용하라.
## Item73. 추상화 수준에 맞는 예외를 던지라.
## Item74. 메서드가 던지는 모든 예외를 문서화하라.
## Item75. 예외의 상세 메시지에 실패 관련 정보를 담으라.
## Item76. 가능한 한 실패 원자적으로 만들라.
## Item77. 예외를 무시하지 말라.
## Item78. 공유 중인 가변 데이터는 동기화해서 사용하라.
## Item79. 과도한 동기화는 피하라.
## Item80. 스레드보다는 실행자, 태스크, 스트림을 애용하라.
## Item81. wait와 notify보다는 동시성 유틸리티를 애용하라.
## Item82. 스레드 안정성 수준을 문서화하라.
## Item83. 지연 초기화는 신중히 사용하라.
## Item84. 프로그램의 동작을 스레드 스케줄러에 기대지 말라.
## Item85. 자바 직렬화의 대안을 찾으라.
## Item86. Serializable을 구현할지는 신중히 결정하라.
## Item87. 커스텀 직렬화 형태를 고려해보라.
## Item88. readObject 메서드는 방어적으로 작성하라.
## Item89. 인스턴수 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라.
## Item90. 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라.