# PART 4.ORM과 투명한 영속성
> - [Domain-Driven Design의 적용-4.ORM과 투명한 영속성 1부](http://aeternum.egloos.com/1366968)
> - [Domain-Driven Design의 적용-4.ORM과 투명한 영속성 2부](http://aeternum.egloos.com/1380433)
> - [Domain-Driven Design의 적용-4.ORM과 투명한 영속성 3부](http://aeternum.egloos.com/1386122)
> - [Domain-Driven Design의 적용-4.ORM과 투명한 영속성 4부](http://aeternum.egloos.com/1421145)
> - [Domain-Driven Design의 적용-4.ORM과 투명한 영속성 5부](http://aeternum.egloos.com/1524214)
> - [Domain-Driven Design의 적용-4.ORM과 투명한 영속성 6부](http://aeternum.egloos.com/1533526)
> - [Domain-Driven Design의 적용-4.ORM과 투명한 영속성 7부](http://aeternum.egloos.com/1540234)
> - [Domain-Driven Design의 적용-4.ORM과 투명한 영속성 8부](http://aeternum.egloos.com/1555909)
> - [Domain-Driven Design의 적용-4.ORM과 투명한 영속성 9부](http://aeternum.egloos.com/1573071)
> - [Domain-Driven Design의 적용-4.ORM과 투명한 영속성 10부](http://aeternum.egloos.com/1648727)
> - [Domain-Driven Design의 적용-4.ORM과 투명한 영속성 11부](http://aeternum.egloos.com/1651174)

- 소프트웨어 모델, 즉 코드가 도메인 모델을 떠오르게 하고 도메인 모델을 바탕으로 예층가능한 방식으로 작동할 경우 두 모델 간의 "표현적 차이가 적다"라고 한다.
- **Domain-Driven Design**은 도메인 모델과 소프트우에ㅓ 모델, 즉 코드 간의 표현적 차이를 최소화하기 위한 접근 방법이다.
    - DDD는 EJB와 같이 기술 주도적인 방식이 아닌 도메인 주도적인 방식으로 소프트웨어를 개발하는 것이다.
- **Domain-Driven Design**을 성공적으로 적용하기 위해서는 기본적으로 두 가지 요소가 필요하다.
    - **Ubiquitous Language**: 고객과 개발자들 사이에 공통된 용어
    - **Model-Driven Design**: 분석, 설계, 구현의 모든 단계를 관통하는 하나의 모델을 만들자는 개념으로 표현적 차이를 줄임으로써 소프트웨어가 도메인의 모습을 투영하도록 만듦
        - 표현적 차이가 적은 객체 지향 언어 사용
        - 비침투적인 POJO 기반의 경량 프레임워크(Spring)

## Reference Object의 별칭(aliasing) - Entity
- Reference Object는 유일성 및 추적성을 만족시키기 위해 식별자를 가지며 동일한 객체를 다른 이름으로 참조할 수 있도록 별칭을 허용한다.
- 별칭은 여러 문제를 야기하지만 시스템의 모든 부분이 Reference Object 상태를 공유할 수 있도록 하여 도메인의 무결성을 유지한다.
- Reference Object는 도메인 객체의 서로 다른 두 가지 측면을 사용하기 위해 사용된다.
    - 의미론적인 측면: 도메인 개념의 유일성과 추적성은 Reference Object의 필요조건이다. 이 측면은 Repository, Aggregate와 같은 다른 도메인 요소에 영향을 미친다.(도메인의 특성)
    - 기술적인 측면: Reference Object 생성 시 메모리 주소를 기반으로 한 식별자를 할당 받으며 `==` 연산자로 동일성을 판단가능하다.(언어 자체의 특성)
- Reference Object의 의미론과 기술론이 충돌하는 영역이 존재한다.
    - 의미론: 도메인의 특성, 본질적인 특성(변하지 않음)
    - 기술론: 언어 자체의 특성, 비본질적인 특성(언어, 환경, 기술에 따라 영향 받음)
- 소프트웨어 개발의 복잡성은 본질적인 특성에 기인한 것이다.
- 도메인의 본질적인 특성을 강조하고 기술에 종속된 비본질적인 개념을 감추기 위해 Reference Object를 대체할 수 있는 용어가 필요하다. => **Entity**
- Entity의 개념은 Reference Object와 동일하다.
    - 식별자를 가진다.
    - 추적 가능하다.
    - 연속성을 가진다.
    - 도메인 개념
- Entity는 표현 매체의 특성이나 기술에 독립적이다.
    - 고객 데이터는 객체, 데이터베이스 레코드, 네트워크 전송을 위해 여러가지 형태의 데이터로 변경되지만 Entity라는 것은 동일하다.
- Entity는 도메인 개념의 연속성과 생명 주기를 구현 기술에 독립적인 문맥 상에서 이해할 수 있도록 한다.
    - 애플리케이션의 고객 객체는 언젠가 GC에 의해 사라지지만 데이터베이스의 해당 고객 레코드는 영원히 남아있다. 이 둘은 같은 고객 엔티티이다.
- Reference Object라는 용어는 생명주기로 인해 혼동될 가능성이 존재한다.

## Entity의 생명 주기
엔터프라이즈 애플리케이션을 구성하는 도메인 객체의 생명 주기를 바라보는 시각은 크게 두 가지이다.
- 도메인 객체의 생명주기를 구현 기술에 종속적인 시각으로 바라보는 것
    - 대표적으로 퍼시스턴스 메커니즘으로 JDBC를 직접 사용하는 **Transaction Script** 패턴 기반이다.
    - 도메인 로직은 Transaction Script 내에서 **절차적** 방식으로 구현되며 도메인 개념은 `getter/setter`만을 가지는 **Anemic Domain Model**로 구성된다.
    - Anemic Domain Model은 도메인 개념을 반영한 클래스명과 속성명을 가지지만 **단순히 레이어 간의 데이터 전달만을 위한 가짜 객체**이다.(즉, 상태를 가지지만 행위는 없다.)
    - 도메인 객체들의 생명주기는 **데이터베이스**와의 상호작용 관점에서 파악됨.
- 도메인 객체의 생명주기를 **Entity** 관점에서 바라보는 것
    - 고객이 신규 가입한 경우 시스템에는 새로운 고객 정보를 가지는 새로운 Entity가 생성되며, 비즈니스 로직을 처리한 후에 고객 Entity는 형태를 바꾸어 데이터베이스 레코드의 형태로 존재한다. 다시 비즈니스 로직이 필요하면 메모리 객체 형태의 Entity로 변환한다.
    - 도메인 객체는 Entity의 한 형태에 불과하다.
    - 도메인 객체가 가비지 컬렉터에 의해 소멸되는 것은 도메인 개념의 소멸이 아닌 형태의 변경에 따른 불필요한 메모리 해제일 뿐이다.
    - 도메인 개념 자체는 사라지지 않는다.
    - 이 시각은 도메인 분석 시에 발견된 연속성과 추적성을 그대로 구현 레벨에 반영한다.
- Entity를 통한 도메인 시스템 개발의 분석/설계는 **Repository**라는 유용한 도구가 있다.
- Repository는 Entity의 생성과 소멸 시점 사이를 책임지는 생명주기 관리 객체이다.
    - Repository를 통해 동일한 Entity를 얻을 수 있다.(유일성 보장)
    - Repository는 내부 구현을 캡슐화하면서 도메인 레이어에 객체 지향적인 컬렉션 관리 인터페이스를 제공한다.
- Repository가 **내부 저장소로 데이터베이스를 사용한다면 지금까지 Reference Object의 동일성을 위한 주소값 비교가 무의미**해진다.
    - 다양한 형태로 옷을 갈아 입는 Entity의 특성을 고려한 새로운 식별자가 필요하다.

## Entity의 식별자(Identity)
- Entity는 추적해야할 도메인 개념이 시간과 장소에 따라 다양한 형태를 지닐 수 있다는 개념을 도메인 모델에 도입한다.
- Entity는 모든 형태가 공유할 수 있는 일반적인 식별자 개념이 필요하다.
- Entity의 식별자로 적당한 속성의 특징은 **데이터베이스 테이블의 후보키(Candidate key) 식별 방법**으로부터 얻을 수 있다.
    - 후보키의 모든 컬럼 값은 NULL이 아니어야 한다.
    - 각 로우는 유일한 값을 가진다.
    - 값이 결코 변경되어서는 안된다.
- 데이터베이스 모델링에서는 이런 특성을 가진 후보키중 가장 적절한 것을 주키(Primary Key)로 하고, 나머지는 유일키(Unique Key)가 된다.
- 데이터베이스는 Entity가 여러 형태를 거쳐 소멸될 때까지 유일성과 추적성을 보장하는 영속성 메커니즘이 적용된 공간이다.
- 데이터베이스 모델링 과정은 Entity 중심의 프로세스로 설명 가능하다.
    - 시스템에서 지속적으로 관리해야 할 Entity를 식별
    - 해당 Entity의 유일성과 추적성을 보장하는 속성을 찾아 Entity의 후보식별자를 선택
    - 후보식별자 중 가장 적절한 것을 최종 식별자로 선택
- **Entity의 식별자는 테이블의 Primary Key와 동일할 것이다.**
- 식별자에 대한 이런 관점은 **Model-Driven Design** 개념 기반이다.
    - 통일된 하나의 기반 모델을 사용하여 소프트웨어 개발을 주도하는 것
    - 관계형 데이터베이스는 엔터프라이즈 애플리케이션에서 대부분 사용하며 데이터베이스라는 하나의 기반으로 애플리케이션 전체의 큰 흐름을 볼 수 있도록 한다.
- 현재까지 도메인 객체를 식별하기 위한 3가지 개념을 살펴보았다.
    - 두 오브젝트가 동일한 **메모리 주소**를 공유하면 이들은 **동일**하다.(객체 식별자, `==`)
    - 두 오브젝트가 동일한 **값**을 가진다면 이들은 **동등**하다.(동등성, `equals`)
    - 두 오브젝트가 **데이터베이스의 동일한 Primary Key**를 공유한다면 이들은 동일하다.(데이터베이스 식별자)
- 데이터베이스 식별자는 `==`로 비교할 수 없고, `equals()`를 오버라이딩해야 한다.
    - `equals()`를 오버라이딩 할 때는 반드시 `hashcode()`도 같이 오버라이딩 해야 한다. 두 오브젝트가 동등하다면, 동일한 해시 코드를 갖는다.

## 객체 관계 맵핑과 도메인 모델
- Domain Model Pattern: 상태와 행위를 함께 가지는 풍부한 객체 모델로 도메인 레이어를 구성
    - 상속, 캡슐화, 다형성과 같은 객체 지향의 장점을 활용 가능
    - 수정에 용이, 높은 확장성, 이해하기 쉬운 시스템
- Domain Model 패턴과 관계형 데이터베이스와의 임피던스 불일치 발생
- 임피던스 불일치를 해결하기 위해 **중간 레이어** 도입
- 객체와 관계형 데이터베이스 간의 독립성을 보장할 수 있도록 객체와 데이터베이스 테이블 간의 데이터를 이동시킨느 객체를 **Data Mapper**라고 한다.
- Data Mapper를 구현한 소프트웨어가 ORM이다.
- ORM은 XML 파일, Java5 Annotation 등을 통해 객체와 데이터베이스 테이블 간의 매핑 정보를 표현할 수 있도록 **MetaData Mapping**을 지원한다.
- 도메인 객체는 자신이 데이터베이스와 연관되어있다는 사실을 알 필요 없이 구현가능하다.
    - 도메인 객체가 하부의 영속성 메커니즘에 독립적인 특징을 **투명한 영속성**(transparent persistance)이라고 한다.
- 정교한 ORM은 로드된 객체들의 상태 변경을 자동으로 감지하고 트랜잭션 commit 시에 변경된 내용을 데이터베이스에 저장한다.(automatic dirty checking)
- ORM은 동일 트랜잭션 내에서 동일한 객체들이 한 번만 로드될 수 있도록 하기 위해 **Identity Map**을 유지한다.
    - 객체가 없을 때만 데이터베이스에 요청
    - 한 트랜잭션 내의 객체는 동일 객체 보장
    - **Repeatable Read** 격리 레벨 준수
- **Lazy Loading** 가능
- 객체가 생성되었지만 단지 메모리 상의 객체로만 존재하고 데이터베이스와 관계가 맺어지지 않은 상태를 **비영속 상태**(transient state)라고 한다.
- 데이터베이스와 연관 관계를 가지는 상태는 **영속 상태**(persistence state)라고 한다.
- ORM은 영속 상태인 객체와 연관된 모든 객체를 영속 상태로 만드는데, 이를 **영속성 전이**(transitive persistance)라고 한다.
    - 이는 Aggregate는 하나의 단위로 처리되야 한다는 것을 보장하기 위함이다.
- **영속 상태인 객체 내부의 Value Object는 하나의 컬럼으로 매핑된다.**

## 영속성 관리 Repository
- 