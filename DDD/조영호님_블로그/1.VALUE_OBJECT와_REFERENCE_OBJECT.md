# PART 1. VALUE OBJECT와 REFERENCE OBJECT
> - [Domain-Driven Design의 적용-1.VALUE OBJECT와 REFERENCE OBJECT 1부](http://aeternum.egloos.com/1105776)
> - [Domain-Driven Design의 적용-1.VALUE OBJECT와 REFERENCE OBJECT 2부](http://aeternum.egloos.com/1111257)
> - [Domain-Driven Design의 적용-1.VALUE OBJECT와 REFERENCE OBJECT 3부](http://aeternum.egloos.com/1114933)
> - [Domain-Driven Design의 적용-1.VALUE OBJECT와 REFERENCE OBJECT 4부](http://aeternum.egloos.com/1115939)

- **Reference Object**
    - 고객, 주문과 같이 실세계의 추적 가능한 개념을 표현
    - 애플리케이션은 어제 주문한 '홍길동'과 오늘 주문한 '홍길동'이 같은 고객인지 식별할 수 있어야 한다.
    - 시스템 내에서 해당 객체를 계속 추적해야할 때
    - 객체가 표현하는 개념이 유일하게 하나만 존재해야 할 때
- **Value Object**
    - 날짜, 금액과 같이 단지 객체를 구성하는 속성들의 값에만 초점을 맞출 뿐 객체의 추적성에는 관심을 두지 않는 객체
    - 객체가 추적할 필요가 없는 단순한 값일 때
    - 속성값이 동일하면 동일한 객체로 간주해도 무방할 때

## 동일함(identical)의 의미
- 모든 객체 지향 시스템은 생성된 객체에게 고유한 식별자를 부여
    - 대부분의 객체 지향 언어는 객체가 위치하고 있는 메모리 상의 주소를 객체의 식별자로 할당하고 이 주소 값을 사용하여 객체 구분
- 자바를 기준으로 `==`는 주소를 비교하므로 Reference Object, `equals(), hashcode()`는 내부 속성 값을 비교하므로 Value Object에 적합하다.
- Reference Object와 Value Object를 구별하는 이유
    - Value Object를 사용함으로써 악명 높은 별칭(aliasing) 문제를 피할 수 있다.

## 별칭(aliasing) 문제
- 자바에서는 하나의 객체를 서로 다른 변수가 참조할 수 있다. 이처럼 동일한 객체를 서로 다른 변수가 참조하는 것을 별칭이라고 한다.
- 별칭의 문제는 서로 다른 참조가 한 객체의 변화에 대해 예상할 수 없기 때문이다.
    - 변수 A, B가 C 객체를 참조할 떄, 변수 A가 객체 C를 변경시키면 변수 B가 가리키는 객체 C도 변경된다. 이 때 변수 B는 이 변화에 대해 예상할 수 없다.
- 별칭 문제로 버그가 발생할 확률이 높다.
    - 특히 여러 개발자가 협업하는 상황일 때
- 별칭을 해결할 수 없는 이유는 **별칭이 만들어지는 것을 막을 수 없다**는 점이다.
    - 해당 객체를 다른 곳에서 사용하려는 순간 별칭은 만들어질 수 밖에 없다.
- 자바의 `final`은 C++의 `const`와 전혀 다르다.
- Bruce Eckel의 "Thinking In Java 3rd Edition"에서 객체를 메서드 인자로 전달할 경우 다음을 주의해야 한다고 말한다.
    - 인자를 전달하는 동안 별칭이 자동으로 생성된다.
    - 지역 객체란 존재하지 않는다. 다만 지역 참조만이 존재할 뿐이다.
    - 참조는 범위를 가지지만 객체는 그렇지 않다.
    - 객체의 생명주기는 자바에서 이슈가 아니다.
    - 자바에는 객체의 수정과 별칭의 무정적인 영항을 막을(`const`와 같은) 언어적인 지원 메커니즘이 존재하지 않는다. 인자 목록에 `final`을 사용할 수는 있지만 이것은 단순히 참조가 다른 객체와 다시 묶이는 것을 막아줄 뿐이다.

## 불변성
- 불변 클래스는 다음과 같은 규칙을 따른다.
    - 객체를 변경하는 메서드를 제공하지 않는다.
    - 재정의할 수 있는 메서드를 제공하지 않는다.
    - 모든 필드를 `final`로 만든다.
    - 모든 필드를 `private`으로 만든다.
    - 가변 객체를 참조하는 필드는 배타적으로 접근해야 한다.
- 불변 객체의 속성을 변경해야 한다면, 변경된 속성의 새로운 객체를 반환한다.

## Value Object와 불변성
- 객체를 불변으로 만들면 별칭 문제를 피할 수 있다.
- **Value Object는 불변 객체여야 한다.**
    - `Money` 객체의 속성 값이 10,000원일 때, 20,000원으로 변경하려 한다.
    - 20,000원을 속성값으로 하는 새로운 `Money` 객체를 생성한다.
    - 기존 10,000원의 `Money` 객체는 아무도 사용하지 않는다면 GC 대상이 된다.
- Value Object가 불변 객체로 만들어도 되는 이유
    - 날짜, 금액과 같은 작은 개념을 의미하므로 새로운 객체를 만들어 대체해도 오버헤드가 적다.
    - 추적성에도 관심을 가질 필요가 없어 동일한 객체를 유지할 필요가 없다.
- Value Object는 전체 도메인의 복잡성을 낮추는 유용한 분석 개념이다.
    - Value Object는 부담 없이 해당 객체를 참조할 수 있다.
    - 객체의 생명 주기가 단순해진다.
- Reference Object는 불변 객체가 아니다.
    - Reference Object의 별칭 문제는 문제가 아니라 요구사항이다.
    - Reference Object는 변경 사항을 추적해야 한다.
    - 하지만 불변 객체로 만들 수 있다면 만드는 것이 최선이다.
- **가능하다면 불변 객체로 시작하다.**
    - 객체에 대한 변경 사항이 시스템의 다른 부분에 전파되어야 한다면 가변 객체로 변경한다.
- Reference Object를 불변으로 만드는 방법은 **상태를 변경하는 메서드를 만들지 않는 것이다.**
    - Reference Object는 Value Object와 달리 시스템 내에 유일하게 존재해야 하므로 새로운 Reference Object를 만들면 안된다.

## 생명 주기 제어
- 객체 지향 시스템은 거대한 객체들의 네트워크로 구성되어 있다.
    - 객체는 상호 연결된 객체들간의 협력을 통해 할당된 책임을 완수한다.
    - 일반적으로 한 객체에서 다른 객체로 이동하기 위해서는 객체 간의 연관 관계를 이용한다.
    - 목적지 객체에 도착하기 위해서는 객체 간의 관계를 항해해야 한다.
    - 객체 그룹의 항해를 위해서는 **시작 객체 Entry Point**가 필요하다.
- Entry Point는 항상 Reference Object이다.
- **Entry Point**
    - 시스템의 요청을 처리하기 위한 객체 그룹의 시작 객체
    - Reference Object이므로 시스템 내에 동일하고 유일해야 한다.(`==` 테스트를 통과해야함)
    - Entry Point의 유일성과 추적성을 유지하기 위한 관리 객체가 필요
- **Entry Point 관리 객체**
    - Entry Point와 관련된 추가, 수정, 삭제, 조회 등의 컬렉션 처리 수행
- Entry Point에 대한 관리 인터페이스를 구성하는 방법
    - 각각의 Entry Point가 스스로 관리 인터페이스를 제공
    - 별도의 객체가 Entry Point에 대한 관리 인터페이스를 제공
- 위 두 방법 모두 메모리 내에서 자신을 쉽게 검색할 수 있도록 키를 제공해야 한다.
- Entry Point의 사용 예시는 3부, 4부 참고

## 도메인의 복잡성
- 복잡한 인간 세상을 담아내는 소프트웨어를 불완전한 인간인 개발자가 만든다는 것은 매우 복잡하고 불완전한 과정에서 이루어진다.
- 복잡성을 완하하기 위한 다양한 기법들을 적용해왔고, 그 중 핵심은 **추상화**이다.
    - 추상화는 불필요한 군더더기를 제거하고 문제 해결에 필요한 핵심 개념만을 도출하여 복잡성을 줄인다.
- Reference Object와 Value Object는 도메인 영역을 추상화하는 한 방법이다.
    - Reference Object와 Value Object의 분리는 도메인 개념들의 추적성과 식별성을 추상화하기 위한 분석 기법
    - 분리를 통해 도메인의 본질적인 특성에 초점을 맞춤
- Reference Object를 식별하여 시스템의 핵심 개념들의 생명 주기에 초점을 맞춘다.
- Value Object를 식별하여 도메인의 일부지만 중요하지 않는 개념을 걸러낸다.
- 단순히 메모리 상에서 Reference Object, Value Object를 관리하는 것은 어렵지 않지만 데이터베이스, 동시성 메커니즘 등이 추가되면서 매우 복잡해진다.
