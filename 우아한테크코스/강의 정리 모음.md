## 우코데 강의(by pobi)
### 프로젝트 3요소
- 비용, 일정, 품질
- 현실은 비용은 적고, 일정은 짧고, 품직은 높아야한다.

### 현장 프로젝트의 현실
- 일정이 품질보다 훨씬 중요하다.
- 생산성이 빠르면 나쁜 코드가 될 확률이 높고, 이는 시간이 지날수록 생산성이 매우 떨어진다.
- 반면에, 클린코드는 생산성을 일정하게 가져갈 수 있다.
- 일정은 맞춰야 한다. 품질을 낮추더라도!
- 처음부터 완벽한 설계를 진행할 수는 없다. 일단 돌아가는 것부터해서 점점 발전시킨다.
  - 빠르게 실패하는 것이 중요하다.

### 점진적인 리팩토링
- 기존의 리팩토링보다 난이도가 있다.
- 현장에서 필요한 기술이다.
- 하나의 프로덕션 코드가 리팩토링이 되면, 모든 테스트 코드에서 에러가 난다.
- 기존 코드에 컴파일 에러가 발생하지 않도록 리팩토링한다.
- 리팩토링 과정에서 테스트 코드가 깨지지 않도록 리팩토링하는 연습이 필요하다.
- 바꾸고 싶은 코드(메서드)를 복사, 붙여넣기를 한다.
- 점진적인 리팩토링을 하면 언제든지 정상적으로 돌아가는 프로그램에서 리팩토링을 할 수 있다.
  - 정상적으로 돌아가는 메서드 역시 존재하기 때문이다.
  - 리팩토링은 로직을 변경하는 것이 아니기 때문에 리팩토링중인 메서드와 기존 메서드가 공존해도 된다.
  - 심지어, 배포해도 상관없다. 로직이 변경되는 것이 아니기 때문에

## 포비 강의
- 프로덕션 코드에 테스트를 위한 코드가 있는 것은 안 좋은 설계다.
- 이를 해결하기 위한 것은 테스트를 위한 코드를 프로덕션에서도 사용하도록 만드는 것이다.
- 이를 위해서는 인터페이스를 사용해야 한다.
- 이러한 패턴을 **Dependency Injection(의존성 주입)** 이다.
- DI패턴을 테스트에 적용하면 프로덕션 코드와 테스트 코드를 일관성있게 사용할 수 있다.

### DI
- 의존관계를 내부가 아닌 외부가 결정해준다.
  - DI를 사용한 Car에서 Car내부에서는 move()할 때 이 값이 랜덤인지 상관하지 않는다.
- 런타임에 의존관계를 결정할 수 있다.
  - Car라는 객체를 다시 컴파일하지 않고 의존관계를 변경할 수 있다.
  - 실행시간에 의존관계를 바꿀 수 있는 것은 아니다.(이것이 가능하면 매우 위험함)
- 오브젝트 그래프에서 아랫단에 있는 객체가 테스트하기 힘들어지면 윗단으로 가는 모든 객체 테스트가 힘들어진다.
  - 아랫단 의존관계를 윗단 의존관계로 변경한다.(인터페이스로 추상화)
  - 위 과정을 반복하면, 아랫단은 계속 테스트할 수 있도록 변경된다.
- 테스트 가능한 유연한 코드를 만들 수 있다.
- DI는 메소드, 생성자 등으로 주입할 수 있다.

## Spring Boot Logging
- logging은 spring boot web에 포함되어 있다.
- ```System.out```은 더이상 사용하면 안된다.
- 설정 파일
  - ```logger```를 가지고 실행하는 것이 ```appender```이다.
  - ```logger```와 ```appender```를 맵핑할 수 있다.
  - ```appender```를 사용해서 콘솔, 파일로 로깅을 저장할 수 있고, 기능별로 다르게 할 수도 있다.
- ```info```까지가 디폴트인데, 이는 개발 환경이 다를 수 있기 때문이다.(배포, 테스트 환경 등)
- log는 배포파일에 포함안되게 할 수 있다.
- ```System.out```와 ```logging```의 차이
  - ```System.out```은 메모리에 적는 것이기 때문에 매우 느리다.
    - 예전에는 이를 주석처리하여 퍼포먼스를 유지했다.
  - ```logging```은 몇 번째 라인에서 에러났는지 표시할 수 있다.
  - ```logging```은 몇 번 쓰레드도 표시할 수 있다.(이도 디버깅하는데 중요)

## 세션 & 로그인 테스트
- ```returnResult()```
  - 각각의 테스트를 동기적으로 실행하도록 만들 수 있다.
  - 결과값을 변수에 답을 수 있다.
- 세션을 한 번 만들어주면, 그 다음 요청은 같은 세션 아이디를 사용하여 쿠키로 다시 보내준다.
  - 이는 브라우저의 역할
  - http는 무상태이므로, 앞의 요청과 뒤의 요청이 같은지 모른다.
  - 그러므로 이를 무식한 방법으로 한번 발급된 쿠키데이터를 모든 데이터에 재사용한다.
  - 이로 클라이언트가 동일한 사람인지 확인한다.
  - **클라이언트는 유일함을 알 수 있는 방법은 쿠키뿐이다.**
  - 세션은 서버에서 아이디를 발급한다.
  - 세션은 쿠키에 종속적이다. 브라우저에서 쿠키를 사용하지 못하게 설정하면 세션도 사용 못한다.
- 테스트는 계속 JSession을 계속 꺼내야한다.
- 요청을  한번 보내면서 똑같은 방법을 내도록 바꾸는 것이좋다.
  - basic auth를 사용할 수 있다.
  - basic은 인증 표준이다.
  - ```Base64Utils```인코딩 표준이다. 이를 알아보자.
- 인터셉터는 컨트롤러를 실행하기 전과 후의 공통적으로 실행하는 로직이다.

### 세션이 만들어지는 시점
- JSession이 만들어지는 시점을 알아보자.
- 세션은 내장 톰캣이 랜덤으로 만든다.
  - 중복되지 않도록 알고리즘되어 있다.(유일성 보장)

### ```@SpringBootTest```
- 테스트에서 컴포넌트 스캔한 모든 빈들을 사용할 수 있다.
- 엡 테스트 환경을 구축해준다.
- webEnvironment
  - RANDOM_PORT: 랜덤 포트로 서버 시작
  - DEFINED_PORT: 설정된 포트로 서버 시작(기본: 8080)
  - MOCK: 서버를 시작하지 않아 가벼운 테스트 환경을 구축, 실제 HTTP요청은 하지 않음, 세션을 직접 설정 가능

- ```@WebMVCTest```는 컨트롤러 단위 테스트가 가능하다.
- ```@DataJpaTest```는 Jpa 테스트
  - 메모리에서 테스트하고 롤백한다.


## 자주 잘못 사용하는 API
### ```HttpSession```
- HttpSession을 사용하면 사용하지 않아도 세션이 발급된다.
  - 스프링에서 인자로 사용되면 세션을 만들어서 넣어준다.
- 세션은 맵이다.
- ```invalidate()```은 세션 안의 모든 데이터가 삭제된다.
  - 오류 발생 위험이 크다.
  - ```removeAttribute()```로 특정 키의 세션 값을 사용한다.

## 포비의 말
- 학습이 느리면 자주 반복해라 이가 쌇이면 속도가 빨라지고 이는 개발 생산성을 높인다.
- 제공하는 코드에서 작은 부분부터 적용하고, 테스트를 어떻게 하는지 생각해보자.
- 궁금하면 코드를 보자.
- 지금은 Jpa를 모르기때문에 기본 제공하는 메서드라도 테스트를 해보자.
- 지금 테스트는 학습 목적이다. 현업가서는 안쓰는 테스트가 많을 수 있다.
  - 이러한 테스트 연습은 학습 속도를 빠르게 만들 수 있는 중요한 요소이다.
- 세션은 클라이언트당 하나의 ID를 발급하고, 그 안에 여러 데이터(키, 값)이 있다.
- 세션은 메모리를 사용하며, 세션에는 반드시 필요한 데이터를 최소한으로 관리한다.
- 한 사용자의 데이터의 세션은 다르게 관리할 수 있는지?
- 세션을 발급한 다음부터 클라이언트를 구분할 시점이 생긴다. 그 전에는 클라이언트를 구분할 데이터가 딱히 없다.
  - 브라우저마다 쿠키를 다르게 구분하기 때문에 같은 로그인 데이터라도 쿠키가 다르면 다르다.
- 쿠키로 하면 서버에서 제어할 수 없다. 그래서 세션을 사용하고, 세션 ID가 그만큼 중요하다. 서버가 털려서 세션이 노출되면 모두 제거하면 된다.


## JPA 객체 관계 매핑
- ORM: 객체를 테이블에 매핑하는 방법이다.
- 자바 클래스의 필드에서 id값을 외래키로 설정하면 ```getter```를 써야 한다. 이는 객체지향적이지 못하다. 그래서 객체 자체를 외래키로 설정해야한다.
- 외래키가 있는 테이블이 주인인 것이 좋다.

### 관계 종류
- ```@OneToOne```
  - 단방향
  - 다른 엔티티에 대한 연결 지정
- ```@ManyToOne```
  - 단방향
- ```@OneToMany```

### column 어노테이션 사용
- 길이 제한, NotNull 설정은 기본

### 테스트
- TestEntityManager는 기본으로 H2 데이터베이스를 사용한다.
  - gradle에 의존성을 추가해야한다.

### ```FetchType```
- 쿼리 확인해볼 것

## 포비의 말
- 양방향을 남용하지 마라.
  - 양방향은 최대한 미뤄라, 최대한 단방향으로 설계하라
- 단방향을 하면 어느쪽에서 객체를 참조하는지가 중요하다.
  - 요구사항에 따라 달라 질 수 있다.
  - 사용자가 게시글 목록을 조회하는 요구사항이 있다.
    - 게시글을 보여줄때 사용자 이름을 보여준다면, 양방향이 편하다고 생각할 수 있다.
    - 그러면, User클래스에 요구사항이 증가하면 복잡도가 매우 증가한다.
  - 이러한 User클래스처럼 많은 기능에서 사용하는 것을 God클래스라고 한다.
- 가능한 ```LAZY``` 상태를 사용하자.
- JPA로만 성능 이슈를 해결할 수 없을 수도 있다. 그 중 캐시를 활용할 수 있다.
