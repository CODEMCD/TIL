# 코딩을 지탱하는 기술

# 1장 효율적으로 언어 배우기

개발자로 일을 하면서 미래에 어떤 언어를 쓸지는 아무도 알지 못한다. 따라서, 특정한 언어에 국한된 지식이 아니라 보다 **보편적인 지식을 습득**할 수 있도록 해야 한다. 이를 위해 '비교를 통한 배움'과 '역사를 통한 배움' 두 가지 방법을 사용한다.

## 비교를 통한 배움

프로그래밍을 위한 언어는 매우 다양하다. 여러 언어를 배우면서 **공통된 개념**이 있다면 이는 중요한 개념으로 다른 언어에도 같은 개념이 있을 확률이 높다. 반면에 언어마다 서로 다른 규칙을 찾는 것도 중요하다. 규칙은 언어마다 다르므로 어떠한 절대적인 약속이 있는 것이 아니다. 그러므로 한 언어에 대한 규칙을 다른 모든 프로그래밍에 적용된다고 판단해서는 안된다.

언어마다 다른 규칙에 대한 예를 한가지 살펴보자. C 언어와 Ruby의 참거짓 값은 서로 반대이다. C 언어는 '**0이 거짓이고,** 그 이외 값은 참이다.' 반면에 Ruby는 **0이 참이다.** 이렇듯 참거짓을 나타내는 값은 언어마다 다르다. Java 역시 이와 다른 규칙을 가지고 있다.

## 역사를 통한 배움

언어를 이해하기 위해서는 **언어 설계자의 의도**를 이해해야 한다. 프로그래밍 언어가 가진 어떤 기능이 '어떤 의미인지' 설명을 읽고도 무언가 모호하다면, 언어 설계자가 어떤 문제를 해결하기 위해 만든 것인지 생각해보자. 그 언어가 어떤 흐름을 따라 만들어졌는지 알게 되면 그 기능이 왜 필요한지 납득할 수 있을 것이다.

언어의 역사를 살펴보다 보면 어떤 언어를 배워야 하는지는 누구도 알지 못한다. 과거 IBM사가 공개한 APL이라는 언어는 업계에서 큰 주목을 받고 미국에서 사용량이 급증했었다. 하지만 현재는 이 언어의 사용자는 거의 찾아보기 힘들다. 반면에 APL 언어와 비슷한 시기에 있었던 C 언어는 현재에도 매우 많이 사용하는 언어이다. 이렇듯 현재에도 수 많은 언어가 생겨나고 있고 주목받고 있지만 어떤 언어가 살아남게 될지는 **아무도 알지 못한다.**

따라서 언어가 바뀌어도 **통용할 수 있는 이해력**을 기르는 것이 중요하다.

# 2장 프로그래밍 언어를 조감하다.

조감하다: 대조하여 보다

## 프로그래밍 언어 탄생의 역사

- 프로그래밍 언어는 인간을 편하게 하기 위해 만들어졌다.
- ENIAC(Electronic Numerical Integrator and Computer)
    - 1946년에 발명된 컴퓨터로, 목적에 따라 프로그램을 변경 할 수 있었다. (즉, 프로그래밍이 가능한 컴퓨터)
    - 17,468개의 진공관을 사용한 거대한 컴퓨터로, 프로그래밍을 하기 위해서 수많은 단자에 케이블을 연결하였다.
    - 프로그램을 변경할 때마다 케이블의 연결을 바꿔주어야 했다.
- EDSAC(Electronic Delay Storage Automatic Calculator)
    - 1949년에 개발된 컴퓨터로, 테이프에 구멍을 뚫어서 데이터를 표현하고 컴퓨터가 이를 읽는 방식이다.
    - 프로그램을 변경하기 위해서 ENIAC는 케이블 연결을 바꾸어 주었지만, EDSAC은 종이 테이프만 바꿔주면 되어 훨씬 간편해졌다.
- FORTRAN
    - 1954년에 만들어진 프로그래밍 언어로 수식을 기계어로 변환가능한 언어이다.
    - 기계어보다 훨씬 비효율적이었지만, 코드를 읽기 쉬웠다.

## 프로그래밍 언어 탄생의 목적

- 프로그램은 어떤 것을 편하게 하기 위해 고안된 것이다.
- 나태, 조바심, 자만심 - 프로그래머의 삼대 미덕
    - 나태(Laziness): 전체 에너지 소비를 줄이기 위해 대부분의 능력을 집중하는 기질
    - 조바심
    - 자만심
- 프로그래밍의 언오의 목적은 '편리함'이지만, 수 많은 언어가 있다. 이는 **언어 설계자의 의도에 따라 서로 다른 '편리함'을 추구하였기 때문이다.**
    - C++은 빠른 실행 속도를 중시하여 C보다 빠르지만, 언어 사양이 복잡해졌다.
    - Scheme은 언어 사양을 쉽게 파악하는데 중점을 두었지만, 수많은 괄호로 이루어져있다.
    - Python은 이해하기 쉬운 코드를 만들도록 하였지만, 속도가 느리며 사양도 단순하지 않다.
- 언어에 따라 편리함의 목적이 다르므로 언어의 단점을 두고 논쟁하는 것은 유익하지 못하다.

# 3장 문법의 탄생

## 문법이란?

- 프로그래밍 언어에는 여러 가지 규칙이 있다.
- 구문은 좀 더 좁은 범위를 가리키는 경우가 많다.
    - 예를 들어, if 문이나 for 문은 '구문'이라 부르며, 연산자 우선순위는 '눈법'이라고 부르는 것이 자연스럽다.
- 문법은 언어 설계자가 정한 규칙이다. 그러므로, 문법은 언어에 따라 다르다.
- '1 더하기 2에 3을 곱한다'라는 똑같은 처리도, 언어에 따라 표현 방법이 다르다.
    - FORTH는 스택을 이용한다.
    - LISP는 구문 트리를 이용한다.

# 4장 처리 흐름 제어

## 구조화 프로그래밍의 탄생

- 1960년대 후반, '사람이 프로그램을 보다 편하게 쓰고 읽을 수 있도록 규칙을 만들자'는 흐름을 타고 '구조화 프로그래밍'이 태어났다.
    - if 문과 while 문 등의 구문을 도입하여 코드 구조를 쉽게 만드는 것이 목표였다.

## if가 탄생하기 전

- 어셈블리어에서는 if문이 없다. 대신 '조건을 만족하면 점프'라는 명령을 사용한다.
    - else if문도 마찬가지로 점프 명령어를 사용한다.
    - else문은 모든 if, else if문의 조건이 만족하지 않으면 실행된다.
- C언어는 else를 사용하지 않고 goto문을 사용할 수 있다.
    - goto 명령은 지정한 행으로 점프하는 명령어이다.
- if-else는 프로그래밍에서 자주 사용하는 패턴인 '조건이 참인 경우와 거짓인 경우의 처리 흐름을 분배한다'를 읽기 쉬운 형태로 나타낼 수 있다.

## while, 반복되는 if를 읽기 쉽게 표현

- while문은 조건이 만족하고 있는 동안 블록 안의 내용을 반복하여 실행하는 구문이다.
- while문 역시 goto문으로 대체할 수 있다.
    - break, continue문 역시 마찬가지다.
- while문을 쓰는 이유는 **읽기 쉽고 쓰기 편하기 위함**이다.
    - goto문을 남용하면 프로그래밍이 엉망진창이 되어버린다.

## for, 수치를 증가시키는 while을 읽기 쉽게 표현

- while문이 있으면 for문은 필요없다고 생각할 수 있다.
- for문은 '0이상 N 미만의 수에 대해 어떤 처리를 한다'를 **쉽게** 표현할 수 있다.
    - while문을 사용하면 몇 줄로 풀어서 사용해야 한다.

## foreach, 처리 대상으로 반복 제어

- for 문이 다시 한 번 진화한 것이다.
- foreach 구문은 '어떤 대상의 요소 전부에 어떤 처리를 한다'는 코드를 **쉽게** 쓰기 위함이다.

## 정리

- while 문은 조건식으로 반복을 제어한다.
- for 문은 횟수로 반복을 제어한다.
- foreach 구문은 처리 대상으로 반복을 제어한다.

# 5장 함수

## 함수의 역할

- 함수는 코드의 일부를 한 덩어리로 잘라내어 그것에 이름을 붙이는 기능이다.

### 이해

- 코드가 함수로 나눠져 있는 것은 큰 조직이 부서로 나눠져 있는 것과 유사하다.
    - 코드 행수가 적으면 어디서 무엇을 하고 있는지 간단히 파악할 수 있다.

### 재사용

- 함수를 만드는 것은 작은 부품을 조립해서 큰 부품을 만드는 것과 유사하다.
- 함수는 어디서든 쉽게 호출해서 사용할 수 있다.
- 함수 내부를 이해하지 않아도 사용할 수 있다.
    - 하지만, 내부를 이해하는 것은 중요하다.
- 같은 처리를 한 군데에 정리하여 생기는 이점은 단순히 프로그램이 짧아진다는 이점도 있지만 소스 코드를 읽는 사람이 몇 번이고 같은 내용의 코드를 읽을 필요도 없어진다.

## 돌아가는 명령

- if, while, for 문은 모두 goto문으로 구현된다. 하지만 goto문은 원래 위치로 돌아가는 명령은 하지 못한다.
    - 왜냐하면, 어디에서 점프해 왔는지 기억하고 있어야 하기 때문이다.
- '원래 위치로 돌아가'는 명령이 있어야 코드를 재사용할 수 있다.
- 돌아갈 목적지를 기록하기 위한 전용 메모리가 나왔다.
    - 일반적으로 레지스터라 불리는 고속 기억 장치를 사용하였다.
    - 하지만, 이 방법에는 문제가 있다. 함수 X를 호출하고 있는 중에 다른 함수 Y를 호출하면, 이를 덮어 씌워져서 함수 X가 돌아갈 목적지가 사라진다.
- 위 문제를 해결하기 위해 **스택**을 사용하였다.

## 재귀 호출

- 재귀 호출은 함수 X 안에서 함수 X 자신을 호출하는 것이다. (재귀 호출을 지원하지 않는 언어도 있다.)
- 재귀 호출을 사용하고 있는 프로그램을 재귀 호출 없이도 만들 수 있다.
    - 재귀로 구현된 하노이 탑 프로그램을 재귀 호출을 사용하지 않고 바꾸는 것이 좋은 연습이 될 수 있다.
- 재귀 호출을 사용하면 매우 편하게 구현할 수 있다.
- 재귀 호출은 다중 내포 관계에서 사용할 수 있다.
    - 다중 내포 관계 특히, 동적으로 내포 관계가 변하는 것은 for문으로 구현할 수 없다. 왜냐하면 2중 내포는 2중 for문, 3중 내포는 3중 for문을 사용하여야 하는데 동적으로 이가 변한다면 코드로 구현할 수 없다.
    - for문으로 구현할 수 있는 것을 재귀로 사용하는 것은 성능상 좋지 않다.

# 6장 에러 처리

## 프로그램도 실패를 한다.

- 프로그램도 실패할 수 있다. 예를 들어, 파일에 무엇을 기록하려고 할 때 하드 디스크가 이미 꽉 차 있는 경우 기록에 실패한다.
- 프로그램이 실패하면 사용자에게 알려야 한다.(실패를 알리는 구조)

## 실패를 어떻게 전달할까?

- 에러를 처리하는 방법은 크게 2 가지가 있다.
    - 반환값으로 실패를 전달하여 호출처가 이를 체크한다. (C언어에서 주로 사용)
    - 어떤 함수를 호출하기 전에 에러 처리 코드를 등록해두고, 실패 시 에러 처리 코드로 점프한다. (현재 언어에서 주로 에러 처리라고 불림)

### 반환값으로 실패를 전달한다.

- 예를 들어, foo함수가 반환하는 값을 성공했을 때 0을 반환, 실패했을 때 그 이외의 값을 반환한다
- 실패 정보는 전역 변수, 함수 내에서 참조 전달하는 방법 등이 있다.
- 2 가지 문제점이 있다.
    - 실패를 놓친다.
        - 프로그래머도 사람이기 때문에 'foo함수가 실패할 가능성이 있다'는 사실을 잊어버린다.
        - 코드를 쓴 타이밍과 문제를 발견하는 타이밍이 어긋나기 때문에, 코드의 문제점을 찾기 힘들다.
        - foo함수가 실패하면 다른 함수까지 연쇄 반응을 일으킬 수 있고, foo함수가 원인이라는 것을 찾기 어렵다.
    - 에러 처리 때문에 코드를 해석하기 어렵다.
        - 모든 함수 호출을 체크한다면, 실제 사용하는 코드 사이에 에러를 처리하는 코드가 들어가기 때문에 흐름을 읽기 어렵다.
        - 이 문제점의 해결 방법으로 점프로 에러 처리를 할 수 있다. C언어에서는 예외 기능이 없으므로, goto문을 사용할 수 있다.

### 실패하면 점프한다.

- C언어가 나오기 한참 전부터 '에러가 발생했을 때 점프할 장소를 사전에 등록해두는' 방법이 존재했으며, 현재의 '예외 처리'가 되었다.
- 1950년에 만들어진 컴퓨터 UNIVAC I의 경우, 오버플로우가 발생하면 등록된 번지에 있는 명령을 실행하는 기능이 있었다. (이를 '인터럽트(interrupt)'라고 불렀다.)
- 1954년에 등장한 FORTRAN에는 예외 처리 기능이 없었다.
- 1959년에 등장한 COBOL에는 현대의 범용적인 예외 처리 구문은 없었지만, 2 가지 예외 처리가 있었다. (파일의 끝인 경우, 오버플로우인 경우)
- 1964년에 등장한 PL/I의 경우 유연하고 통일된 에러 처리를 위해 'ON 구문'을 도입했다.(**실패 했을 때 처리를 등록하는 기능**)
    - 에러가 발생하면 ERROR로 점프하는 코드는 on error go to ERROR; 와 같이 사용하였다.
    - **실패 종류를 추가할 수 있는 기능**과 **실패를 발생시키는 기능**도 존재했으며, 이는 현대 예외 처리에도 계승되었다.

## 실패할 것 같은 처리를 묶는 구문

- PL/I는 '미리 실패했을 때 처리를 등록해둔 후 실패할 것 같은 코드를 쓰는' 형식이다.
- Java는 '실패할 것 같은 코드를 미리 try{...}로 묶어둔 후 실패했을 때 처리를 쓰는' 형식이다.
- John Good enough는 "프로그래머는 '명령'이 예외를 던질 가능성이 있다는 것을 잊어버리고 최적이 아닌 장소 또는 최적이 아닌 종류의 예외 처리를 사용하는 등의 실수를 할 가능성이 있다. 이 가능성을 줄이고 프로그래머가 한 실수를 컴파일러가 경고하도록 하기 위해서는 2 가지가 필요하다.
    - 명령이 어떤 예외를 던질 가능성이 있는지 명시적으로 선언한다.
    - 자발적으로 '실패할 것 같은 처리'를 묶는 구문을 사용한다.
- 현재 Java와 같은 현대 대부분의 언어는 위의 2번째 방식을 확장하여 '실패할 것 같은 처리를 묶은 후 에러 처리를 나중에 기술'하는 구문을 채용하고 있다.
- 1975년부터 1977년 사이, 프로그래밍 언어 CLU는 begin ... end로 '블록'으로 설정하고 이 사이에 '실패할 것 같은 처리'를 excep 구문을 추가하여 처리하였다.
- 1983년에 등장한 C++는 실패할 것 같은 처리의 앞 부분에 try를, 발생한 실패를 캐치하는 처리 블록 앞에 catch라는 키워드를 사용하는 구문을 추가하였다.
    - 예외를 발생시키기 위한 명령으로 throw라는 용어를 만들었다.
- 1990년경에 Microsoft 사는 C 언어로 새로운 OS인 Windows NT 3.1을 만들었고, '구조화 예외'(Structured Exception Handling, SEH)를 도입하였다.
    - 구조화 예외에는 __try, __except, __finally라는 키워드가 있다.

## 출구는 하나다.

### Microsoft 사는 왜 finally를 도입한 것 일까?

- Microsoft 사의 대답은 다음과 같다.

> 구조화 예외 처리를 채용함으로 코드의 신뢰성을 높일 수 있었다. 예를 들어, 프로그래머가 예측하지 못한 종료가 발생했을 시 메모리 블록이나 파일 등의 리소스를 잘 닫을 수 있게 된다. 또한 메모리 부족 등의 특정 문제에 대해서도 goto 구문이나 반환값 개념을 사용하지 않고 간단한 구조화 코드로 대응할 수 있다.

### 짝이 되는 처리를 반드시 실행한다.

- '짝이 되는 처리'는 메모리를 확보한 후 나중에 개방한다거나, 파일을 열었다가 닫는 처리, 락(Lock)을 걸었다가 푸는 처리 등이 있다.
- 함수에서 짝이 되는 처리를 한 쪽 실행했다면, 함수의 출구(return)에서 다른 한쪽도 반드시 실행되어야 한다.
- 함수의 출구가 여러 개라면, 짝의 다른 한쪽을 선언해주는 것이 어려워진다.
    - 예를 들어, 함수의 시작에서 lock을 하면, return문 이전에 unlock을 해주어야 한다. 하지만 return문이 여러 곳에 존재하면 unlock 역시 여러 개를 선언해주어야 한다.
- 짝이 되는 처리를 해주기 위해 finally를 사용할 수 있다.
    - finally 블록은 처리가 try 블록에서 벗어날 때 반드시 실행된다.
    - try 블록 안에서 예외가 발생하든지 발생하지 않든지, finally 블록은 반드시 실행된다.
- C++는 finally가 없다.
    - C++는 RAII(Resource Acquisition Is Initialization: 리소스 확보는 초기화 시에)라는 기술을 사용하며, 이를 구현하는 것이 클래스의 생성자와 소멸자이다.
    - 클래스의 생성자를 불러 인스턴스를 만들면, 해당 스코프를 나가는 순간 소멸자가 실행된다.
- 2001년에 등장한 D언어는 짝이되는 처리 한쪽이 선언된 바로 다음에 다른 한쪽을 선언하도록 만들었다. 이는 스코프 카드(scope guard)를 사용하여 스코프(함수)를 벗어나면 미리 설정해둔 처리가 실행된다.

## 어떤 경우에 예외를 던질까?

- 예외는 예외적인 상황에 한정해서 사용해야 한다.

### 함수 호출 시 인수가 부족한 경우

- Python과 Ruby는 함수의 인수가 부족한 경우 함수 호출 시점에서 예외를 던진다.
- JavaScript는 안수에 '미정의를 의마하는 특수한 값'(undefined)을 사용해서 처리를 계속한다.

### 배열 범위 밖에 있는 것을 취득하려고 했을 때

- 배열 범위 밖에 있는 것을 접근하려 할 때
    - Python은 예외를 던진다.
    - Ruby는 '없는 것을 의미하는 특수한 값'(nil)을 반환한다.
    - JavaScript는 undefined를 반환한다.
- 위 3가지 언어의 예외 처리 상황을 보았을 때, 어떤 경우에 예외를 던질지에 대해선 의견이 일치하지 않는다.
- '예외적 상황'이란 무엇인지에 대한 **정답은 없다.**

### 틀리면 바로 예외를 던진다.

- 프로그래머도 사람인 이상, 실수를 피할 수 없다. 그러므로 무언가가 이상하다면 바로 예외를 던지는 것이 좋다.
- '이상하면 처리를 정지하고 빨리 보고해야 한다'는 설계 이념을 '패일 퍼스트'(fail first)라고 부른다.
- 특히, 학습이나 개발 단계에서는 패일 퍼스트 설계 방식이 이점이 많다.

## 예외의 전파

- Java를 포함해서 대부분의 예외 처리에서는 예외가 호출처로 전파된다.
- f→g→h 의 방향으로 호출하는 함수들이 있다고 가정하자.
    - h함수에서 예외가 발생하면, 먼저 h함수에서 예외를 처리하는 코드가 있는지 확인하고 없으면 g함수, 그 다음 f함수를 조사한다.
    - 만약 3개의 함수에 에러 처리를 하지 않으면 프로그램은 비정상 종료가 된다.

### 예외 전파의 문제점

- 위 예제에서 f함수가 호출하는 모든 함수의 코드를 살펴 보아야 어떤 예외가 발생하는지 알 수 있다.

### Java의 검사 예외

- Java는 'throw에서 던질 수 있는 것' 즉, 예외라고 부르는 것을 다음과 같이 더 세분화하였다.
    - 예외 처리를 하지 않아도 되는 중요한 문제
    - 예외 처리르 ㄹ해도 좋은 실행 시 예외
    - 예외 처리를 해도 좋은 기타 예외
        - 기타 예외는 검사 예외라고도 불리며, 만약 메소드 밖으로 던지는 것이면 그것을 메소드 정의 시에 선언해줄 필요가 있다.
- 검사 예외를 사용하면 깜박하고 예외를 던질 가능성을 놓쳐버리는 일은 발생하지 않는다.
    - 예외를 처리하지 않으면 컴파일 에러가 발생하기 때문이다.
- 어떤 메소드가 예외를 던질 가능성이 있는 foo함수를 호출할 경우에 두 가지 선택지가 있다.
    - foo 함수가 던지는 예외를 그대로 호출처로 전달한다.
    - foo 함수가 던지는 예외를 자신이 처리한다.

### 검사 예외가 잘 사용되지 않는 이유

- 귀찮기 때문이다.
- C#은 많은 부분을 Java에서 참고하고 있지만, 검사 예외는 사용하고 있지 않다.

# 7장 이름과 스코프

## 왜 이름이 필요할까?

- 함수나 변수의 이름이 발명되기 전에는 3,456번과 같은 메모리 번지를 사용했다.
- 사람은 물건이나 장소에 '알기 쉬운 이름'을 붙여 그것을 편하게 가리킨다.
- 위와 같은 이유로 프로그래밍도 사람이 하는 것이기 때문에 쉽게 이해하고 편하게 사용하기 위해 이름을 사용한다.

### 이름 충돌

- 초기 프로그래밍 언어에서는 대응표를 프로그램 전체에서 공유하고 있었다.
- 예를 들어, 반복문에서 i 변수가 10이 될 때까지 반복하는 코드가 있다.  이 반복문 안에서 foo함수를 호출하고 있는데, 이 함수에서는 i를 0값으로 바꾼다. 전체 프로그램에서 대응표를 공유하는 언어에서는 i라는 변수가 전체 단 하나이기 때문에 이 반복문은 끝나지 않고 무한반복하게 된다.

### 충돌 피하기

- 초기 프로그래밍 언어에서는 변수명이 유효한 범위가 프로그램 전체였다. 즉, '이 변수는 전역 스코프다'라고 표현한다. 더 짧게는 '전역 변수'라고 부른다.
- 변수명이 중복되는 것을 방지하려면 다음과 같은 방법이 있다.
    - 긴 변수명을 사용한다.
    - 스코프를 이용한다.

## 스코프의 진화

- 스코프(scope)란 이름의 유효 범위이다.
- 프로그램 전체에서 이름 충돌을 방지하는 것은 어렵기 때문에 이름의 유효 범위를 좁게 설정한다.

### 동적 스코프

- 이름 충돌 해결 방법 중 하나는 함수 입구에 원래의 값을 기록해두고(**다른 변수에 저장해두고**) 출구에서 원래 값으로 되돌리는 것이다.(해당 변수에 이전에 저장해둔 변수값을 대입한다.)
- 이 방법은 함수의 return 문 전에 반드시 원래 값으로 되돌리는 작업이 있어야한다.
- 이를 자동으로 해주는 것은 1991년 Perl 4부터 변수를 local 키워드로 선언하는 것이다.
    - local 키워드로 선언된 변수는 '원래의 값을 다른 곳에 피신시켜두고 나중에 되돌린다'를 알아서 해준다.
    - 이런 스코프를 **동적 스코프**라고 한다.
- 동적 스코프의 문제점은 '**변수를 변경한 후 다른 함수를 호출한 경우 호출된 함수에 영향을 미친다**'는 것이다.
    - 동적 스코프에서는 변경값이 호출되는 곳에 파급되기 때문에, 변수값을 참조했을 때 어떤 값이 될지는 호출처의 코드를 보지 않고서는 알 수 없다.

### 정적 스코프

- 전역 스코프나 동적 스코프는 대응표를 프로그램 전체에 걸쳐서 몇 개의 함수가 공유하고 있었다.
    - 여러 사람이 하나의 화이트 보드를 공유해서 작업하는 것과 같다.
    - 동적 스코프의 문제점은 바꾸지 전의 값을 읽을 수 없다.
- 위 문제점을 해결하기 위해서는 함수가 호출될 때마다 새로운 대응표를 만들 수 있다.
    - 한 명 한명이 자신의 책상에 메모 용지를 가지고 있는 것이다.
- 동적 스코프는 해당 변수의 동적 스코프 대응표를 만들지만, 이는 **소스 코드 전역에서 읽고 쓸 수 있다.** (하지만 이를 호출하는 함수는 이 값이 바뀐 후 값이다.)
    - 이것이 정적 스코프와의 가장 큰 차이점이다.
- 정적 스코프는 쉽게 말하면 **함수별로 대응표를 보유한다.**
- 현대 언어는 대부분 정적 스코프를 도입하고 있다.
- 요즘 '전역 변수는 악이다' 라고 말하는 것은 동적 스코프, 전역 스코프의 배경에서 시작되었다.
    - 즉, 문제가 발생하지 않도록 영향 범위를 최대한 작게하는 기능을 만든 것이다.

## 정적 스코프는 완성체인가?

### 내포 함수의 문제점

- 내포된 것처럼 보이는 스코프가 실제로는 내포되어 있지 않다.
- Python 언어에서 foo함수가 bar함수를 내포한다.
    - 전역 변수 x는 "global" 값을 저장하고 있다.
    - foo함수의 변수 x는 "local" 값을 저장하고 있다.
    - bar함수에서 변수 x를 출력하면, local이 출력될 것 같지만, global을 출력한다.
- 이 문제점은 가까운 대응표를 찾아서 먼저 참조되도록 해결되었다.

### 외부 스코프에 재귀속되는 문제

- 내포한 스코프의 외부 변수를 변경할 수 없다.
- Python 언어에서 함수안에서 대입하면 그 함수의 지역 변수가 된다.
- 대입은 '해당 스코프에 이미 같은 이름의 변수가 있으면 해당 변수를 재귀속시키고, 없으면 해당 스코프에서 새로운 지역 변수를 작성'한다.
    - '귀속'이란 간단히 이름과 값을 연결시키는 것이다. '재귀속'이란 x가 다른 값을 가리키도록 연결을 수정하는 것을 말한다.
- 이는 외부 스코프에 영향을 미치지 않는 것으로, 외부 스코프에 있는 변수를 변경할 수 없다는 것을 의미한다.
- Python 3.0은 nonlocal 키워드로 지역 변수로 만들지 않는 방법을 사용했다.

## 정리

- 객체 지향에서 private, public, proteced 접근 제어자는 동적 스코프와 닮았다.
- Java는 정적 스코프 언어이지만 클래스는 소스 코드 어디서든 참조할 수 있다. (클래스는 전역 스코프이다.)
    - 클래스는 이름이 계층적으로 이루어져 있고, 임포트하지 않으면 사용할 수 없기 때문에 전역 변수가 가지고 있던 충돌 문제를 해결하였다.

# 8장 형

## 형(型)이란?

- 형은 사람이 데이터에 붙인 '추가 데이터'이다.
- 컴퓨터 안에 저장되어 있는 데이터는 On과 Off, 0과 1의 집합으로 표현된다. 이들을 모아둔 것을 비트열이라 한다.
- 같은 비트열이라도 '그것을 어떤 종류의 값으로 해석할지'에 따라 틀린 값이 되어버린다.
- 위를 피하기 위해 '어떤 종류의 값인가?'라는 정보를 추가한 것이 형의 시작이다.

## 수치를 On과 Off로 표현하는 방법

- 초기에는 램프가 켜진 개수로 수를 표현했다. 예를 들어 '3을 표현하기 위해 3개의 램프를 켠다.'
    - 이 방법으로 0부터 999까지 표현하려면 999개 램프가 필요하다.
- 컴퓨터가 탄생하기 1000년 이상 전에 인류는 자릿수 기수법을 발명했다.
    - 이 방법으로 0부터 999까지 표현하려면 27개 램프가 필요하다.
- 컴퓨터가 탄생하기 전에 하나의 자리를 7개의 램프로 표현하는 방법이 방법이 발명되었다.(7 세그먼트 디스플레이)
    - 이 방법으로 0부터 999까지 표현하려면 21개 램프가 필요하다.
- 주판은 5개로 하나의 자리를 표현한다. 이로 세 자리를 표현하려면 15개의 램프가 필요하다.

## 한 자리에 필요한 램프는 몇 개일까?

- 하나의 램프로 2가지 부호를 표현할 수 있다.
- UNIVAC I 등 초기 컴퓨터는 4개의 On/Off를 사용해서 수치를 표현했다.(Excess-3)
    - 이 방법으로는 0부터 999까지 표현하려면 12개 램프가 필요하다.
- 램프 4개로 16가지를 표현할 수 있음에도 10가지만 사용하는 것은 비효율적이다. 이를 보완하기 위해 10진수가 아닌 2진수를 사용하게 되었다.