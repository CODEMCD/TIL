# 징검다리 건너기
- [문제 링크](https://programmers.co.kr/learn/courses/30/lessons/64062?language=java)

## 1. 문제 이해
징검다리 건너기 방법
- 징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.
- 디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.
- 단, 다음으로 밟을 수 있는 디딤돌이 **여러 개인 경우 무조건 가장 가까운 디딤돌로만** 건너뛸 수 있습니다.

최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.

## 2. 문제 조건
디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones, 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k

- 징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.
- stones 배열의 크기는 1 이상 200,000 이하입니다.
- stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.
- k는 1 이상 stones의 길이 이하인 자연수입니다.

## 3. 문제 설계
완전 탐색으로 문제를 풀면 최대 시간 복잡도는 200,000 * 200,000,000 이므로 매우 오랜 시간이 소요된다.

징검다리가 0인 값의 연속된 길이를 Key로 잡고, 이분 탐색을 통해 어떤 수를 뺐을 때 해당 Key값이 되는지 검사한다.
    - 이의 시간 복잡도는 O(NlogM)이다. (N은 stones 배열의 최대 길이, M은 stones 배열 원소의 최대 값)
    - 징검다리의 최소값이 1이므로, K가 1이어도 최소 한 명은 건넌다.
    - 이분 탐색은 stones 배열의 최소값을 left, 최대값은 right로 두고 탐색을 시작한다.
    - 이분 탐색을 하는 동안 0이 연속된 최대길이를 계산한다. - O(N)

위처럼 생각했는데, 이분 탐색하면서 건널 수 있는 사람의 최대값을 어떻게 구현할지 생각이 안나서 다른 사람의 코드를 봤다. 코드를 이해하고 보니 이분 탐색의 while문 자체가 left가 right를 넘어서는 그 순간 빠져나가게 되는데, 이가 최대값이 된다는 것으로 이해할 수 있었다. 그리고 문제 설계는 카카오 해설이 더 이해하기 쉬울 것 같아 아래에 첨부했다.

```
연속된 K개의 디딤돌에 적힌 숫자가 모두 0인 구간이 있으면 더 이상 징검다리를 건널 수 없으며, 이를 이용해 이분 탐색하면 문제를 해결할 수 있습니다. 먼저 M번째 친구가 징검다리를 건널 수 있는지 확인하기 위해 M – 1 번째 친구까지 징검다리를 건넌 상황을 구합니다. 이때, M – 1번째 친구까지는 K값에 관계없이 모두 징검다리를 건넜다고 가정합니다. 따라서, 징검다리에 적힌 숫자가 M보다 작다면 숫자가 0이 됐다고 표시해주면 됩니다. 이제 M번째 친구가 징검다리를 건널 수 있는지 확인하기 위해 징검다리에서 0이 연속으로 K개가 나오는 구간이 있는지 확인합니다.

- 0이 연속으로 K개가 나오는 구간이 있는 경우 : M번째 친구는 징검다리를 건널 수 없습니다.
- 또한, M번째 친구보다 뒤에 건너는 친구들은 모두 징검다리를 건널 수 없습니다.
- 따라서 찾아야 하는 답은 0 이상 M – 1 이하인 정수 중 하나입니다.
- 0이 연속으로 K개가 나오는 구간이 없는 경우 : M번째 친구는 징검다리를 건널 수 있습니다.
- 이 경우 첫 번째 ~ M – 1 번째 친구들은 모두 정상적으로 징검다리를 건널 수 있습니다.
- 따라서 찾아야 하는 답은 M 이상 MAX값 이하인 정수 중 하나입니다.

답이 될 수 있는 최솟값과 최댓값의 중간값으로 M값을 계속 변경해 주면 효율적으로 탐색 범위를 줄여나갈 수 있습니다. 위 풀이의 경우 시간 복잡도는 O(nlogm)이 되며, n은 디딤돌의 개수, m은 디딤돌에 적힌 숫자의 최댓값입니다. 이 외에 O(n) 풀이 방법도 있으니 한 번 고민해보세요.
```

## 4. 문제 구현

- left, right를 문제 조건의 최대/최소값으로 하는 것이 stones 배열의 최대/최소값하는 것보다 2배이상 빠른 것으로 나타났다. 내 예상에는 stones 배열의 최대/최소로하면 반으로 나누는 크기가 작아서 더 많이 이분 탐색을 해야하는 것은 아닐까 생각해본다...

```java
class Solution {
    public int solution(int[] stones, int k) {
        int left = 1;
        int right = 200000000;
        
        while (left <= right) {
            int mid = (left + right) / 2;
            
            if (canCross(stones, mid, k)) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        
        return left;
    }
    
    private boolean canCross(int[] stones, int m, int k) {
        int zeroLine = 0;
        for (int i=0; i<stones.length; ++i) {
            if (stones[i] - m <= 0) {
                ++zeroLine;
            } else {
                zeroLine = 0;
            }
            
            if (zeroLine >= k) {
                return false;
            }
        }
        
        return true;
    }
}
```
